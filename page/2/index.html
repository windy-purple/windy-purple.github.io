<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"windy-purple.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="windy_ll">
<meta property="og:url" content="https://windy-purple.github.io/page/2/index.html">
<meta property="og:site_name" content="windy_ll">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="windy_ll">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://windy-purple.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>windy_ll</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">windy_ll</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/10/12/26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/12/26/" class="post-title-link" itemprop="url">Android so(ELF)文件解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-12 09:18:26" itemprop="dateCreated datePublished" datetime="2020-10-12T09:18:26+08:00">2020-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:02:32" itemprop="dateModified" datetime="2024-11-12T23:02:32+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>22 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p><strong>&ensp;&ensp;&ensp;&ensp;so文件是啥？so文件是elf文件，elf文件后缀名是<code>.so</code>，所以也被chang常称之为<code>so文件</code>,elf文件是linux底下二进制文件，可以理解为windows下的<code>PE文件</code>，在Android中可以比作<code>dll</code>，方便函数的移植，在常用于保护Android软件，增加逆向难度。解析elf文件有啥子用？最明显的两个用处就是：1、so加固；2、用于frida(xposed)的检测！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;本文使用c语言，编译器为vscode。如有错误，还请斧正！！！</strong>  </p>
<hr>
<h1 id="二、SO文件整体格式"><a href="#二、SO文件整体格式" class="headerlink" title="二、SO文件整体格式"></a>二、SO文件整体格式</h1><p><strong>&ensp;&ensp;&ensp;&ensp;so文件大体上可分为四部分，一般来说从上往下是<code>ELF头部-&gt;Pargarm头部-&gt;节区(Section)-&gt;节区头</code>，其中，除了<code>ELF头部</code>在文件位置固定不变外，其余三部分的位置都不固定。整体结构图可以参考非虫大佬的那张图，图片如下：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;解析语言之所以选择c语言，有两个原因：1、做so加固的时候可以需要用到，这里就干脆用c写成一个模板，哪里需要就哪里改，不像上次解析dex文件的时候用python写，结果后面写指令还原的时候需要用的时候在写一遍c版本代价太大了；2、在安卓源码中，有个<code>elf.h</code>文件，这个文件定义了我们解析时需要用到的所有数据结构，并且给出了参考注释，是很好的参考资料。<code>elf.h</code>文件路径如下：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/2.png"></p>
<hr>
<h1 id="三、解析ELF头部"><a href="#三、解析ELF头部" class="headerlink" title="三、解析ELF头部"></a>三、解析ELF头部</h1><p><strong>&ensp;&ensp;&ensp;&ensp;ELF头部数据格式在elf.h文件中已经给出，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/3.png">  </p>
<p><strong>&ensp;&ensp;每个字段解释如下：</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1、e_ident数组：前4个字节为<code>.ELF</code>，是elf标志头，第5个字节为该文件标志符，为1代表这是一个32位的elf文件，后面几个字节代表版本等信息。<br>&ensp;&ensp;&ensp;&ensp;2、e_type字段：表示是可执行文件还是链接文件等，安卓上的so文件就是分享文件，一般该字段为3，详细请看下图。<br>&ensp;&ensp;&ensp;&ensp;3、e_machine字段：该字段标志该文件运行在什么机器架构上，例如ARM。<br>&ensp;&ensp;&ensp;&ensp;4、e_version字段：该字段表示当前so文件的版本信息，一般为1.<br>&ensp;&ensp;&ensp;&ensp;5、e_entry字段：该字段是一个偏移地址，为程序启动的地址。<br>&ensp;&ensp;&ensp;&ensp;6、e_phoff字段：该字段也是一个偏移地址，指向程序头(Pargram Header)的起始地址。<br>&ensp;&ensp;&ensp;&ensp;7、e_shoff字段：该字段是一个偏移地址，指向节区头(Section Header)的起始地址。<br>&ensp;&ensp;&ensp;&ensp;8、e_flags字段：该字段表示该文件的权限，常见的值有1、2、4，分别代表read、write、exec。<br>&ensp;&ensp;&ensp;&ensp;9、e_ehsize字段：该字段表示elf文件头部大小，一般固定为52.<br>&ensp;&ensp;&ensp;&ensp;10、e_phentsize字段：该字段表示程序头(Program Header)大小，一般固定为32.<br>&ensp;&ensp;&ensp;&ensp;11、e_phnum字段：该字段表示文件中有几个程序头。<br>&ensp;&ensp;&ensp;&ensp;12、e_shentsize:该字段表示节区头(Section Header)大小，一般固定为40.<br>&ensp;&ensp;&ensp;&ensp;13、e_shnum字段：该字段表示文件中有几个节区头。<br>&ensp;&ensp;&ensp;&ensp;14、e_shstrndx字段：该字段是一个数字，这个表明了<code>.shstrtab节区(这个节区存储着所有节区的名字，例如.text)</code>的节区头是第几个。  </p>
<p><strong>&ensp;&ensp;<code>e_type</code>具体值(相关值后面有英文注释，这里就不再添加中文注释了)：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/4.png">  </p>
<p><strong>&ensp;&ensp;解析代码如下：</strong>  </p>
<pre><code>struct DataOffest parseSoHeader(FILE *fp,struct DataOffest off)
&#123;
    Elf32_Ehdr header;
    int i = 0;

    fseek(fp,0,SEEK_SET);
    fread(&amp;header,1,sizeof(header),fp);
    printf(&quot;ELF Header:\n&quot;);
    printf(&quot;    Header Magic: &quot;);
    for (i = 0; i &lt; 16; i++)
    &#123;
        printf(&quot;%02x &quot;,header.e_ident[i]);
    &#125;
    printf(&quot;\n&quot;);
    printf(&quot;    So File Type: 0x%02x&quot;,header.e_type);
    switch (header.e_type)
    &#123;
    case 0x00:
        printf(&quot;(No file type)\n&quot;);
        break;
    case 0x01:
        printf(&quot;(Relocatable file)\n&quot;);
        break;
    case 0x02:
        printf(&quot;(Executable file)\n&quot;);
        break;
    case 0x03:
        printf(&quot;(Shared object file)\n&quot;);
        break;
    case 0x04:
        printf(&quot;(Core file)\n&quot;);
        break;
    case 0xff00:
        printf(&quot;(Beginning of processor-specific codes)\n&quot;);
        break;
    case 0xffff:
        printf(&quot;(Processor-specific)\n&quot;);
        break;
    default:
        printf(&quot;\n&quot;);
        break;
    &#125;
    printf(&quot;    Required Architecture: 0x%04x&quot;,header.e_machine);
    if (header.e_machine == 0x28)
    &#123;
        printf(&quot;(ARM)\n&quot;);
    &#125;
    else
    &#123;
        printf(&quot;\n&quot;);
    &#125;
    printf(&quot;    Version: 0x%02x\n&quot;,header.e_version);
    printf(&quot;    Start Program Address: 0x%08x\n&quot;,header.e_entry);
    printf(&quot;    Program Header Offest: 0x%08x\n&quot;,header.e_phoff);
    off.programheadoffset = header.e_phoff;
    printf(&quot;    Section Header Offest: 0x%08x\n&quot;,header.e_shoff);
    off.sectionheadoffest = header.e_shoff;
    printf(&quot;    Processor-specific Flags: 0x%08x\n&quot;,header.e_flags);
    printf(&quot;    ELF Header Size: 0x%04x\n&quot;,header.e_ehsize);
    printf(&quot;    Size of an entry in the program header table: 0x%04x\n&quot;,header.e_phentsize);
    printf(&quot;    Program Header Size: 0x%04x\n&quot;,header.e_phnum);
    off.programsize = header.e_phnum;
    printf(&quot;    Size of an entry in the section header table: 0x%04x\n&quot;,header.e_shentsize);
    printf(&quot;    Section Header Size: 0x%04x\n&quot;,header.e_shnum);
    off.sectionsize = header.e_shnum;
    printf(&quot;    String Section Index: 0x%04x\n&quot;,header.e_shstrndx);
    off.shstrtabindex = header.e_shstrndx;
    return off;
&#125;
</code></pre>
<hr>
<h1 id="四、程序头-Program-Header-解析"><a href="#四、程序头-Program-Header-解析" class="headerlink" title="四、程序头(Program Header)解析"></a>四、程序头(Program Header)解析</h1><p><strong>&ensp;&ensp;&ensp;&ensp;程序头在<code>elf.h</code>文件中的数据格式是<code>Elf32_Phdr</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/5.png">  </p>
<p><strong>&ensp;&ensp;每个字段解释如下：</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1、p_type字段：该字段表明了段(Segment)类型，例如<code>PT_LOAD</code>类型，具体值看下图，实在有点多，没办法这里写完。<br>&ensp;&ensp;&ensp;&ensp;2、p_offest字段：该字段表明了这个段在该so文件的起始地址。<br>&ensp;&ensp;&ensp;&ensp;3、p_vaddr字段：该字段指明了加载进内存后的虚拟地址，我们静态解析时用不到该字段。<br>&ensp;&ensp;&ensp;&ensp;4、p_paddr字段：该字段指明加载进内存后的实际物理地址，跟上面的那个字段一样，解析时用不到。<br>&ensp;&ensp;&ensp;&ensp;5、p_filesz字段：该字段表明了这个段的大小，单位为字节。<br>&ensp;&ensp;&ensp;&ensp;6、p_memsz字段：该字段表明了这个段加载到内存后使用的字节数。<br>&ensp;&ensp;&ensp;&ensp;7、p_flags字段：该字段跟elf头部的e_flags一样，指明了该段的属性，是可读还是可写。<br>&ensp;&ensp;&ensp;&ensp;8、p_align字段：该字段用来指明在内存中对齐字节数的。  </p>
<p><strong>&ensp;&ensp;<code>p_type</code>字段具体取值：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/6.png">  </p>
<p><strong>&ensp;&ensp;解析代码：</strong>  </p>
<pre><code>struct DataOffest parseSoPargramHeader(FILE *fp,struct DataOffest off)
&#123;
    Elf32_Half init;
    Elf32_Half addr;
    int i;
    Elf32_Phdr programHeader;
    
    init = off.programheadoffset;
    for (i = 0; i &lt; off.programsize; i++)
    &#123;
        addr = init + (i * 0x20);
        fseek(fp,addr,SEEK_SET);
        fread(&amp;programHeader,1,32,fp);
        switch (programHeader.p_type)
        &#123;
        case 2:
            off.dynameicoff = programHeader.p_offset;
            off.dynameicsize = programHeader.p_filesz;
            break;
        default:
            break;
        &#125;
        printf(&quot;\n\nSegment Header %d:\n&quot;,(i + 1));
        printf(&quot;    Type of segment: 0x%08x\n&quot;,programHeader.p_type);
        printf(&quot;    Segment Offset: 0x%08x\n&quot;,programHeader.p_offset);
        printf(&quot;    Virtual address of beginning of segment: 0x%08x\n&quot;,programHeader.p_vaddr);
        printf(&quot;    Physical address of beginning of segment: 0x%08x\n&quot;,programHeader.p_paddr);
        printf(&quot;    Num. of bytes in file image of segment: 0x%08x\n&quot;,programHeader.p_filesz);
        printf(&quot;    Num. of bytes in mem image of segment (may be zero): 0x%08x\n&quot;,programHeader.p_memsz);
        printf(&quot;    Segment flags: 0x%08x\n&quot;,programHeader.p_flags);
        printf(&quot;    Segment alignment constraint: 0x%08x\n&quot;,programHeader.p_align);
    &#125;
    return off;
&#125;
</code></pre>
<hr>
<h1 id="五、节区头-Section-Header-解析"><a href="#五、节区头-Section-Header-解析" class="headerlink" title="五、节区头(Section Header)解析"></a>五、节区头(Section Header)解析</h1><p><strong>&ensp;&ensp;&ensp;&ensp;节区头在elf.h文件中的数据结构为<code>Elf32_Shdr</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/7.png">  </p>
<p><strong>&ensp;&ensp;每个字段解释如下：</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1、sh_name字段：该字段是一个索引值，是<code>.shstrtab</code>表(节区名字字符串表)的索引，指明了该节区的名字。<br>&ensp;&ensp;&ensp;&ensp;2、sh_type字段：该字段表明该节区的类型，例如值为<code>SHT_PROGBITS</code>,则该节区可能是<code>.text</code>或者<code>.rodata</code>，至于具体怎么区分，当然看sh_name字段。具体取值看下图。<br>&ensp;&ensp;&ensp;&ensp;3、sh_flags字段：跟上面的一样，就不再细说了。<br>&ensp;&ensp;&ensp;&ensp;4、sh_addr字段：该字段是一个地址，是该节区加载进内存后的地址。<br>&ensp;&ensp;&ensp;&ensp;5、sh_offset字段：该字段也是一个地址，是该节区在该so文件中的偏移地址。<br>&ensp;&ensp;&ensp;&ensp;6、sh_size字段：该字段表明了该节区的大小，单位是字节。<br>&ensp;&ensp;&ensp;&ensp;7、sh_link和sh_info字段：这两个字段只适用于少数节区，我们这里解析用不到，感兴趣的可以去看官方文档。<br>&ensp;&ensp;&ensp;&ensp;8、sh_addralign字段：该字段指明在内存中的对齐字节。<br>&ensp;&ensp;&ensp;&ensp;9、sh_entsize字段：该字段指明了该节区中每个项占用的字节数。  </p>
<p><strong>&ensp;&ensp;<code>sh_type</code>取值：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/8.png">  </p>
<p><strong>&ensp;&ensp;解析代码：</strong>  </p>
<pre><code>struct DataOffest parseSoSectionHeader(FILE *fp,struct DataOffest off,struct ShstrtabTable StrList[100])
&#123;
    Elf32_Half init;
    Elf32_Half addr;
    Elf32_Shdr sectionHeader;
    int i,id,n;
    char ch;
    int k = 0;

    init = off.sectionheadoffest;
    for (i = 0; i &lt; off.sectionsize; i++)
    &#123;
        addr = init + (i * 0x28);
        fseek(fp,addr,SEEK_SET);
        fread(&amp;sectionHeader,1,40,fp); 
        switch (sectionHeader.sh_type)
        &#123;
        case 2:
            off.symtaboff = sectionHeader.sh_offset;
            off.symtabsize = sectionHeader.sh_size;
            break;
        case 3:
            if(k == 0)
            &#123;
                off.stroffset = sectionHeader.sh_offset;
                off.strsize = sectionHeader.sh_size;
                k++;
            &#125;
            else if (k == 1)
            &#123;
                off.str1offset = sectionHeader.sh_offset;
                off.str1size = sectionHeader.sh_size;
                k++;
            &#125;
            else
            &#123;
                off.str2offset = sectionHeader.sh_offset;
                off.str2size = sectionHeader.sh_size;
                k++;
            &#125;
            break;
        default:
            break;
        &#125;
        id = sectionHeader.sh_name;
        printf(&quot;\n\nSection Header %d\n&quot;,(i + 1));
        printf(&quot;    Section Name: &quot;);
        for (n = 0; n &lt; 50; n++)
        &#123;
            ch = StrList[id].str[n];
            if (ch == 0)
            &#123;
                printf(&quot;\n&quot;);
                break;
            &#125;
            else
            &#123;
                printf(&quot;%c&quot;,ch);
            &#125;
        &#125;
        printf(&quot;    Section Type: 0x%08x\n&quot;,sectionHeader.sh_type);
        printf(&quot;    Section Flag: 0x%08x\n&quot;,sectionHeader.sh_flags);
        printf(&quot;    Address where section is to be loaded: 0x%08x\n&quot;,sectionHeader.sh_addr);
        printf(&quot;    Offset: 0x%x\n&quot;,sectionHeader.sh_offset);
        printf(&quot;    Size of section, in bytes: 0x%08x\n&quot;,sectionHeader.sh_size);
        printf(&quot;    Section type-specific header table index link: 0x%08x\n&quot;,sectionHeader.sh_link);
        printf(&quot;    Section type-specific extra information: 0x%08x\n&quot;,sectionHeader.sh_info);
        printf(&quot;    Section address alignment: 0x%08x\n&quot;,sectionHeader.sh_addralign);
        printf(&quot;    Size of records contained within the section: 0x%08x\n&quot;,sectionHeader.sh_entsize);
    &#125;
    return off;
&#125;
</code></pre>
<hr>
<h1 id="六、字符串节区解析"><a href="#六、字符串节区解析" class="headerlink" title="六、字符串节区解析"></a>六、字符串节区解析</h1><p><strong>&ensp;&ensp;&ensp;&ensp;PS:从这里开始网上的参考资料很少了，特别是参考代码，所以有错误的地方还请斧正；因为以后的so加固等只涉及到几个节区，所以只解析了<code>.shstrtab</code>、<code>.strtab</code>、<code>.dynstr</code>、<code>.text</code>、<code>.symtab</code>、<code>.dynamic</code>节区！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;在elf头部中有个<code>e_shstrndx</code>字段，该字段指明了<code>.shstrtab</code>节区头部是文件中第几个节区头部，我们可以根据这找到<code>.shstrtab</code>节区的偏移地址，然后读取出来，就可以为每个节区名字赋值了，然后就可以顺着锁定剩下的两个字符串节区。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;在elf文件中，字符串表示方式如下：字符串的头部和尾部用标示字节<code>00</code>标志，同时上一个字符串尾部标识符<code>00</code>作为下一个字符串头部标识符。例如我有两个紧邻的字符串分别是<code>a</code>和<code>b</code>，那么他们在elf文件中16进制为<code>00 97 00 98 00</code>。</strong>  </p>
<p><strong>&ensp;&ensp;解析代码如下(PS:因为编码问题，第一次打印字符串表没问题，但填充进sh_name就乱码，所以这里只放上解析<code>.shstrtab</code>的代码，但剩下两个节区节区代码一样)：</strong>  </p>
<pre><code>void parseStrSection(FILE *fp,struct DataOffest off,int flag)
&#123;
    int total = 0;
    int i;
    int ch;
    int mark;
    Elf32_Off init;
    Elf32_Off addr;
    Elf32_Word count;

    mark = 1;


    if (flag == 1)
    &#123;
        count = off.strsize;
        init = off.stroffset;
    &#125;
    else if (flag == 2)
    &#123;
        count = off.str1size;
        init = off.str1offset;
    &#125;
    else
    &#123;
        count = off.str2size;
        init = off.str2offset;
    &#125;
</code></pre>
<p>​<br>        printf(“String Address&#x3D;&#x3D;&gt;0x%x\n”,init);<br>        printf(“String List %d:\n\t[1]&#x3D;&#x3D;&gt;”,flag);</p>
<pre><code>    for (i = 0; i &lt; count; i++)
    &#123;

        addr = init + (i * 1);

        fseek(fp,addr,SEEK_SET);
        fread(&amp;ch,1,1,fp);

        if (i == 0 &amp;&amp; ch == 0)
        &#123;
            continue;
        &#125;
        else if (ch != 0)
        &#123;
            printf(&quot;%c&quot;,ch);
        &#125;
        else if (ch == 0 &amp;&amp; i !=0)
        &#123;
            printf(&quot;\n\t[%d]==&gt;&quot;,(++mark));
        &#125;
    &#125;
    printf(&quot;\n&quot;);
    
&#125;
</code></pre>
<hr>
<h1 id="七、-dynamic解析"><a href="#七、-dynamic解析" class="headerlink" title="七、.dynamic解析"></a>七、.dynamic解析</h1><p><strong>&ensp;&ensp;&ensp;&ensp;<code>.dynamic</code>在<code>elf.h</code>文件中的数据结构是<code>Elf32-Dyn</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/9.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;第一个字段表明了类型，占4个字节；第二个字段是一个共用体，也占四个字节，描述了具体的项信息。解析代码如下：</strong>  </p>
<pre><code>void parseSoDynamicSection(FILE *fp,struct DataOffest off)
&#123;
    int dynamicnum;
    Elf32_Off init;
    Elf32_Off addr;
    Elf32_Dyn dynamicData;
    int i;

    init = off.dynameicoff;
    dynamicnum = (off.dynameicsize / 8);

    printf(&quot;Dynamic:\n&quot;);
    printf(&quot;\t\tTag\t\t\tType\t\t\tName/Value\n&quot;);

    for (i = 0; i &lt; dynamicnum; i++)
    &#123;
        addr = init + (i * 8);
        fseek(fp,addr,SEEK_SET);
        fread(&amp;dynamicData,1,8,fp);
        printf(&quot;\t\t0x%08x\t\tNOPRINTF\t\t0x%x\n&quot;,dynamicData.d_tag,dynamicData.d_un);
    &#125;
    
&#125;
</code></pre>
<hr>
<h1 id="八、-symtab解析"><a href="#八、-symtab解析" class="headerlink" title="八、.symtab解析"></a>八、.symtab解析</h1><p><strong>&ensp;&ensp;&ensp;&ensp;该节区是该so文件的符号表，它在<code>elf.h</code>文件中的数据结构是<code>Elf32_Sym</code>，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/10.png">  </p>
<p><strong>&ensp;&ensp;每个字段解释如下：</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;1、st_name字段：该字段是一个索引值，指明了该项的名字。<br>&ensp;&ensp;&ensp;&ensp;2、st_value字段：该字段表明了相关联符号的取值。<br>&ensp;&ensp;&ensp;&ensp;3、stz-size字段：该字段指明了每个项所占用的字节数。<br>&ensp;&ensp;&ensp;&ensp;4、st_info和st_other字段：这两个字段指明了符号的类型。<br>&ensp;&ensp;&ensp;&ensp;5、st_shndx字段：相关索引。  </p>
<p><strong>&ensp;&ensp;解析代码如下(PS：由于乱码问题，索引手动固定了地址测试，有兴趣的挨个解析字符应该可以解决乱码问题)：</strong>  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">void parseSoDynamicSection(FILE *fp,struct DataOffest off)</span><br><span class="line">&#123;</span><br><span class="line">    int dynamicnum;</span><br><span class="line">    Elf32_Off init;</span><br><span class="line">    Elf32_Off addr;</span><br><span class="line">    Elf32_Dyn dynamicData;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    init = off.dynameicoff;</span><br><span class="line">    dynamicnum = (off.dynameicsize / 8);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Dynamic:\n&quot;);</span><br><span class="line">    printf(&quot;\t\tTag\t\t\tType\t\t\tName/Value\n&quot;);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; dynamicnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = init + (i * 8);</span><br><span class="line">        fseek(fp,addr,SEEK_SET);</span><br><span class="line">        fread(&amp;dynamicData,1,8,fp);</span><br><span class="line">        printf(&quot;\t\t0x%08x\t\tNOPRINTF\t\t0x%x\n&quot;,dynamicData.d_tag,dynamicData.d_un);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    void parseSymtabSection(FILE *fp,struct DataOffest off)</span><br><span class="line">    &#123;</span><br><span class="line">        Elf32_Off init;</span><br><span class="line">        Elf32_Off addr;</span><br><span class="line">        Elf32_Word count;</span><br><span class="line">        Elf32_Sym symtabSection;</span><br><span class="line">        int k,i;</span><br><span class="line"></span><br><span class="line">        init = off.symtaboff;</span><br><span class="line">        count = off.symtabsize;</span><br><span class="line"></span><br><span class="line">        printf(&quot;SymTable:\n&quot;);</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            addr = init + (i * 16);</span><br><span class="line">            fseek(fp,addr,SEEK_SET);</span><br><span class="line">            fread(&amp;symtabSection,1,16,fp);</span><br><span class="line">            printf(&quot;Symbol Name Index: 0x%x\n&quot;,symtabSection.st_name);</span><br><span class="line">            printf(&quot;Value or address associated with the symbol: 0x%08x\n&quot;,symtabSection.st_value);</span><br><span class="line">            printf(&quot;Size of the symbol: 0x%x\n&quot;,symtabSection.st_size);</span><br><span class="line">            printf(&quot;Symbol&#x27;s type and binding attributes: %c\n&quot;,symtabSection.st_info);</span><br><span class="line">            printf(&quot;Must be zero; reserved: 0x%x\n&quot;,symtabSection.st_other);</span><br><span class="line">            printf(&quot;Which section (header table index) it&#x27;s defined in: 0x%x\n&quot;,symtabSection.st_shndx);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="九、-text解析"><a href="#九、-text解析" class="headerlink" title="九、.text解析"></a>九、.text解析</h1><p><strong>&ensp;&ensp;&ensp;&ensp;PS：这部分没代码了，只简单解析一下，因为解析arm指令太麻烦了，估计得写个半年都不一定能搞定，后续写了会同步更新在github!!!</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;<code>.text</code>节区存储着可执行指令，我们可以通过节区头部的名字锁定<code>.text</code>的偏移地址和大小，找到该节区后，我们会发现这个节区存储的就是arm机器码，直接照着指令集翻译即可，没有其他的结构。通过ida验证如下：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/11.png">  </p>
<hr>
<h1 id="十、代码测试相关截图"><a href="#十、代码测试相关截图" class="headerlink" title="十、代码测试相关截图"></a>十、代码测试相关截图</h1><p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/12.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/13.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/14.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/15.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//soparser/16.png">  </p>
<hr>
<h1 id="十一、frida反调试和后序"><a href="#十一、frida反调试和后序" class="headerlink" title="十一、frida反调试和后序"></a>十一、frida反调试和后序</h1><p><strong>&ensp;&ensp;&ensp;&ensp;frida反调试最简单的就是检查端口，检查进程名，检查so文件等，但最准确以及最复杂的是检查汇编指令，我们知道frida是通过一个大调整实现hook，而跳转的指令就那么几条，我们是否可以通过检查每个函数第一条指令来判断是否有frida了！！！(ps：简单写一下原理，拉开写就太多了，这里感谢某大佬和我讨论的这个话题！！！)</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;本来因为这个so文件解析要写到明年去了，没想到看起来代码量大，但实际要用到的地方代码量很少。。。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;源码github链接：<a target="_blank" rel="noopener" href="https://github.com/windy-purple/parseso/">https://github.com/windy-purple/parseso/</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/09/09/43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/09/43/" class="post-title-link" itemprop="url">安卓加固方案从落地加载到类指令抽取编写报告</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-09 14:27:43" itemprop="dateCreated datePublished" datetime="2020-09-09T14:27:43+08:00">2020-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 23:00:57" itemprop="dateModified" datetime="2024-11-12T23:00:57+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>7.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言以及环境配置"><a href="#一、前言以及环境配置" class="headerlink" title="一、前言以及环境配置"></a>一、前言以及环境配置</h1><p><strong>&ensp;&ensp;&ensp;&ensp;PS:突然想起来好久没在看雪发过啦，这次就同步一下吧！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;PS:该文已经首发于某公众号，介意者勿喷！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;安卓的加固方案是从19年底开始写的，到现在为止差不多快一年了，写这个目的还是学习怎么脱壳，前几个月再看雪看到有人直接分析壳来学习，不过我感觉从加壳写起也是一种浪漫。因为个人原因，在类指令抽取壳哪里为半完成状态，在今年大概率没有时间接着修改了，在java层的加固就止于此吧！！！(PS:以后有时间会接着修改)</strong>  </p>
<p><strong>&ensp;&ensp;环境配置：</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;</strong><br>&ensp;&ensp;&ensp;&ensp;* Android studio v3.5.3<br>&ensp;&ensp;&ensp;&ensp;* 华为G621-TL00 android v4.4.4  </p>
<hr>
<h1 id="二、第一代壳：落地加载"><a href="#二、第一代壳：落地加载" class="headerlink" title="二、第一代壳：落地加载"></a>二、第一代壳：落地加载</h1><h2 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h2><p><strong>&ensp;&ensp;&ensp;&ensp;a、原理很简单，就是首先将我们的dex文件或者apk文件解密，然后利用<code>DexClassLoader</code>加载器将其加载进内存中，然后利用反射加载待加固的apk的appkication，然后运行待加固程序即可，我画了个流程图详细说明如下：</strong>  </p>
<p>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;b、上面说了大概原理，现在来说明一下具体细节，我们知道，在一个app开始运行的时候，第一个加载的类是<code>ActivityThread</code>,该类有个关键属性<code>currentActivityThread</code>，通过该属性能够获取到一系列其他关键的属性，例如<code>mPackages</code>，通过该属性，我们可以获取到<code>mClassLoader</code>属性，通过替换该属性我们可以替换系统加载器，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/2.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;接着来说怎么获取待加固apk的application，这个通过在脱壳apk的AndroidManifest.xml中使用<code>meta-data</code>来获取，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/3.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;在然后就是怎么替换application，我们可以知道在android.app.LoadedApk类中有一个方法<code>makeApplication</code>可以生成一个application，通过该方法生成一个application，然后通过替换<code>android.content.ContentProvider</code>类中的<code>mContext</code>属性完成application的替换，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/4.png">  </p>
<h2 id="2、实际操作"><a href="#2、实际操作" class="headerlink" title="2、实际操作"></a>2、实际操作</h2><p><strong>&ensp;&ensp;&ensp;&ensp;ps:因为第一代壳网上一大堆，所以讲得很粗略，同时这也不是本文的重点！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;通过上面的代码我们可以得到脱壳apk，然鹅待加固的apk放在哪里，网上大多放在脱壳dex的尾部，我又画了一张图，应该可以看图就懂了：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/5.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;这个我采用通过python读取二进制然后重新计算chunksum和签名字段实现，代码入戏：</strong>  </p>
<pre><code>import binascii
import hashlib
import zlib

def fixCheckSum(shell):
    shell.seek(0x0c)
    data = shell.read()
    checksum = zlib.adler32(data)
    strchecksum = str(hex(checksum))
    strchecksum = strchecksum.replace(&#39;0x&#39;,&#39;&#39;)
    b = bytes(strchecksum.encode(&#39;utf-8&#39;))
    a = bytearray(b)
    c = binascii.hexlify(binascii.unhexlify(bytes(a))[::-1])
    dataCheckSum = bytearray(c)
    shell.seek(0x08)
    shell.write(dataCheckSum)

def fixSHA1(shell):
    shell.seek(0x20)
    signBytes = shell.read()
    sha1 = hashlib.sha1()
    sha1.update(signBytes)
    sign = sha1.hexdigest()
    tmp = bytes(sign.encode(&#39;utf-8&#39;))
    b = bytearray(tmp)
    shell.seek(0x0c)
    shell.write(b)

def fixFileSize(shell,num):
    b = bytearray()
    for i in range(4):
        number = int(num % 256)
        b.append(number)
        num = num &gt;&gt; 8
    shell.seek(0x20)
    shell.write(b)

def IntToHex(num):
    b = bytearray()
    for i in range(4):
        number = int(num % 256)
        b.append(number)
        num = num &gt;&gt; 8
    b.reverse()
    return b

def main():
    sourceApk = open(&#39;sourceApk.apk&#39;,&#39;rb+&#39;,True)
    unshell = open(&#39;unshell.dex&#39;,&#39;rb+&#39;,True)
    filename = &#39;classes.dex&#39;
    
    tmpApk = sourceApk.read()
    print(&#39;[*] 成功读取待加壳的APK文件&#39;)
    sourceArray = bytearray(tmpApk)
    tmpDex = unshell.read()
    print(&#39;[*] 成功读取脱壳DEX文件&#39;)
    unshellArray = bytearray(tmpDex)
    print(&#39;[-] 待加壳APK文件开始加密，加密类型为：未加密&#39;)
    
    sourceApkLen = len(sourceArray)
    unshellLen = len(unshellArray)
    print(&#39;[+] 加密后的APK大小为&#39; + str(sourceApkLen) + &#39;Byte&#39;)
    totalLen = sourceApkLen + unshellLen + 4
    
    tmpByteArray = unshellArray + sourceArray
    newdex = tmpByteArray + IntToHex(sourceApkLen)
    print(&#39;[+] 所有二进制数据合成完毕&#39;)
    
    shellTmp = open(filename,&#39;wb+&#39;,True)
    shellTmp.write(newdex)
    shellTmp.close()
    print(&#39;[+] 数据写入&#39; + filename + &#39;完毕&#39;)
    
    shell = open(filename,&#39;rb+&#39;,True)
    fixFileSize(shell,len(newdex))
    print(&#39;[+] 文件大小修改完毕&#39;)
    fixSHA1(shell)
    print(&#39;[+] 文件SHA-1签名头部修改完毕&#39;)
    fixCheckSum(shell)
    print(&#39;[+] 文件校验头头部修改完毕&#39;)
    print(&#39;[+] 待加壳APK文件sourceApk.apk加壳完毕，加壳后DEX文件&#39; + filename + &#39;生成完毕&#39;)
    shell.close()
    
if __name__ == &#39;__main__&#39;:
    main()
</code></pre>
<p><strong>&ensp;&ensp;&ensp;&ensp;将上述apk重新签名后，安装运行，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/6.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/7.png">  </p>
<h2 id="3、遇到的问题"><a href="#3、遇到的问题" class="headerlink" title="3、遇到的问题"></a>3、遇到的问题</h2><p><strong>&ensp;&ensp;&ensp;&ensp;运行时报错如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/8.png"></p>
<p><strong>&ensp;&ensp;&ensp;&ensp;解决方案：报错显示无法实例化activity，经过检查是无法加载到正确格式的dex文件，检查你的解密代码，即使是你加密是象征型的异或了一个0xff，解密时也不能因为异或0xff值不变而不异或0xff。其次是打包成apk之前删除签名文件之后在签名！！！</strong>  </p>
<hr>
<h1 id="三、第二代壳：不落地加载"><a href="#三、第二代壳：不落地加载" class="headerlink" title="三、第二代壳：不落地加载"></a>三、第二代壳：不落地加载</h1><h2 id="1、原理-1"><a href="#1、原理-1" class="headerlink" title="1、原理"></a>1、原理</h2><p><strong>&ensp;&ensp;&ensp;&ensp;大体原理和第一代壳相同，和第一代壳不同的是，第一代壳将dex文件解密出来会保存到文件中，在通过DexClassLoader加载进内存中，而不落地加载直接重写<code>DexClassLoader</code>使其可以直接加载字节数组，避免写入文件中。我们要做的是重写<code>DexClassLoader</code>，而这涉及到三个函数<code>defineClass</code>、<code>findClass</code>、<code>loadClass</code>，在一个类被加载的时候，会先后调用这三个函数加载一个类，所以我们需要重写这三个函数，但是我们怎么在重写的过程中操控dex中的类(通过字节数组加载进来的并不能直接操控)？其实系统的DexClassLoader加载dex进入内存的也必然是通过字节加载的，而在系统so中的<code>libdvm.so</code>中的<code>openDexFile</code>可以直接加载dex文件，那么现在清楚了，我们可以通过编写so文件调用<code>openDexFile</code>函数加载dex字节数组，值得注意的是，<code>openDexFile</code>函数返回值为一个<code>int</code>类型的cookie，可以简单理解成一个dex文件的’身份码’，通过该’身份码’即可操控这个dex文件,至于怎么调用该函数，可以通过<code>dlopen</code>和<code>dlsym</code>函数调用，相关代码如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/9.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/10.png">  </p>
<h2 id="2、实际操作-1"><a href="#2、实际操作-1" class="headerlink" title="2、实际操作"></a>2、实际操作</h2><p><strong>&ensp;&ensp;&ensp;&ensp;a、首先编写样本，这里我写了一个类和一个方法，作用就是打印一个特征字符串，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/11.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;b、将上面的样本打包成apk后提取出dex文件然后放置到assest文件夹下(该文件夹需要自己建立)供程序调用（ps：我这里图方便未对dex文件加密然后解密，有需要的可以加上），然后脱壳apk和上面的第一代壳没什么区别，唯一不同的是就是我们使用的是我们自己重写的<code>DexClassLoader</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/12.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;c、运行截图如下：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/13.png">  </p>
<h2 id="3、遇到的问题-1"><a href="#3、遇到的问题-1" class="headerlink" title="3、遇到的问题"></a>3、遇到的问题</h2><p><strong>&ensp;&ensp;a、报错<code>java.lang.UnsatisfiedLinkError: Native method not found</code></strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;解决方案：在配置文件中添加<code>packagingOptions&#123;         pickFirst &quot;lib/armeabi-v7a/libtwoshell.so&quot;         pickFirst &quot;lib/arm64-v8a/libtwoshell.so&quot;         pickFirst &quot;lib/x86/libtwoshell.so&quot;         pickFirst &quot;lib/x86_64/libtwoshell.so&quot;     &#125;</code>，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/14.png">  </p>
<p><strong>&ensp;&ensp;b、运行到加载dex文件中的方法时，app直接闪退</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;解决方案：重写的<code>loadClass</code>方法有问题，不能通过直接super调用父类方法，而是应该通过反射调用<code>defineClassNative</code>方法，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/15.png">  </p>
<hr>
<h1 id="四、第三代壳：类指令抽取壳"><a href="#四、第三代壳：类指令抽取壳" class="headerlink" title="四、第三代壳：类指令抽取壳"></a>四、第三代壳：类指令抽取壳</h1><h2 id="1、原理-2"><a href="#1、原理-2" class="headerlink" title="1、原理"></a>1、原理</h2><p><strong>&ensp;&ensp;&ensp;&ensp;a、什么是类指令抽取壳，从名字就能看出来，就是把dex文件中的方法指令抽空，变成<code>nop</code>，然后在运行时再将指令还原！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;b、指令抽取可以通过010修改，现在来说指令还原，其余代码和第二代基本一样，不一样的地方在加载完dex之后执行指令还原函数，指令还原现在有两种方法，第一种是通过读取<code>maps</code>文件获取加载的dex文件地址，然后对dex文件进行解析，找到被nop的指令处进行还原(ps：该种方法需要及其熟悉dex文件格式，不了解的可以看我之前的文章关于解析dex文件，因为我之前解析的时候用的是python，改成c要大量时间，所以我选择了第二种方法)；第二种方法就是通过免root hook系统函数(最简单的就是deFindClass函数)然后进行指令还原！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;c、接下来就将一下怎么通过hook dexFindClass函数来进行指令还原(PS:看懂下面的内容需要理解dex文件格式)。<code>dexFindClass</code>函数在<code>libdvm.so</code>库中，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/16.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;免root hook框架有点多，我选择的是android inline hook，原因很简单，很适合在so层使用，其他的经过我测试不知道为啥我写出来的没反应，该框架github地址：<a target="_blank" rel="noopener" href="https://github.com/ele7enxxh/Android-Inline-Hook">https://github.com/ele7enxxh/Android-Inline-Hook</a>，用法可以参考作者github，该inline hook框架需要原函数地址、新函数地址和原始函数的二级指针，用法如下所示(怎么使用不是重点，接下来的才是重点，所以这里比较粗略)：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/17.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;我们要hook的是<code>dexFindClass</code>函数，该函数定义在<code>DexFile.h</code>文件中，该函数返回值为一个类结构指针，第二个参数为类名字，通过该参数我们就可以指定类进行指令还原，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/18.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/19.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;上面我们得到的<code>classDataOff</code>，我们可以通过该地址获取到类数据，该偏移地址指向的是一个<code>DexClassData</code>结构，该结构的<code>header</code>存储了相关类信息，该结构的<code>directMethods</code>指针指向的方法的结构题，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/20.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;通过<code>directMethods</code>指针我们可以顺着找到<code>DexMethod</code>结构体，通过该结构体的<code>methodIdx</code>调用系统函数<code>dexGetMethodId</code>、<code>dexStringById</code>可以获取到方法名字，精确还原方法指令，通过该结构的<code>codOff</code>(这是个偏移地址)可获取方法指令，该偏移地址指向<code>DexCode</code>结构，该结构即存储了方法指令，利用memcpy替换即可达到指令还原的效果，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/21.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/22.png">  </p>
<h2 id="2、实践操作"><a href="#2、实践操作" class="headerlink" title="2、实践操作"></a>2、实践操作</h2><p><strong>&ensp;&ensp;&ensp;&ensp;java层基本和第二代壳一样，只是多了一个调用hook的函数，so层关键代码如下所示：(ps：不知道为啥Android inline hook稳定性很差，上一个测试app还得行，下一个就疯狂报错了，所以代码是基本完成了，但是android inline hook报错未解决，有时间我会修改)</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/23.png">  </p>
<h2 id="3、遇到的问题-2"><a href="#3、遇到的问题-2" class="headerlink" title="3、遇到的问题"></a>3、遇到的问题</h2><p><strong>&ensp;&ensp;&ensp;&ensp;报错未定义函数，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/24.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;解决方案：在CmakeLists.txt文件中将jni文件夹下面所有引用到的文件都包含进去，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//androidshell/25.png">  </p>
<hr>
<h1 id="五、后记及其相关链接"><a href="#五、后记及其相关链接" class="headerlink" title="五、后记及其相关链接"></a>五、后记及其相关链接</h1><p><strong>&ensp;&ensp;&ensp;&ensp;我个人习惯了通过写加固来学习脱壳，可能时间比直接分析壳来得慢，但是这其中体验真的酸爽到爆炸，因为个人原因，最后的类指令抽取壳最后一点没弄完，算是一个小遗憾吧，20年应该没时间来弥补这个遗憾了，希望21年我有时间来把这个遗憾补上吧！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;源码github链接：<a target="_blank" rel="noopener" href="https://github.com/windy-purple/androidshell">https://github.com/windy-purple/androidshell</a></strong>  </p>
<p><strong>&ensp;&ensp;参考链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="http://www.520monkey.com/archives/1115">Android免Root权限通过Hook系统函数修改程序运行时内存指令逻辑</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="http://www.520monkey.com/archives/815">Android逆向之旅—运行时修改内存中的Dalvik指令来改变代码逻辑</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c5580215ee26">Android中免root的hook框架Legend原理解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://github.com/asLody/legend">https://github.com/asLody/legend</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://github.com/ele7enxxh/Android-Inline-Hook">https://github.com/ele7enxxh/Android-Inline-Hook</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ltyandy/p/11644056.html">Android APK加固-完善内存dex</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ce20fa304e1e">利用动态加载技术加固APK原理解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1035ffd9e9cf">Android插件化框架之动态加载Activity（一）</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44045581/article/details/89811868">Android APK 加固之动态加载dex（一）</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="http://www.520monkey.com/archives/1118">Android中实现「类方法指令抽取方式」加固方案原理解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="http://www.520monkey.com/archives/629">Android中apk加固完善篇之内存加载dex方案实现原理(不落地方式加载)</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/08/12/36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/12/36/" class="post-title-link" itemprop="url">安卓逆向从0到1学习总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-12 16:39:36" itemprop="dateCreated datePublished" datetime="2020-08-12T16:39:36+08:00">2020-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 22:59:16" itemprop="dateModified" datetime="2024-11-12T22:59:16+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><strong>&ensp;&ensp;&ensp;&ensp;PS:该文已经首发于某公众号，介意者勿喷！！！</strong></p>
<p><strong>&ensp;&ensp;&ensp;&ensp;初识安卓逆向是在2019年的暑假，到现在也快一年了，这一年来有刚从web渗透转来的迷茫，有成功破解了第一个app的喜悦，也有通宵熬夜逆向的心酸，到现在感觉自己成功踏进逆向大门的满足感。原本打算在入门之后弄个安卓逆向教程作为总结，但是吧，写文章教程，各大论坛都有，而且还写得挺好，例如52论坛的&lt;&lt;教我兄弟学逆向&gt;&gt;教程，自己再去写就没多大意思了；做视频教程吧，因为个人原因，没有那么多时间去录制视频和剪辑视频。谨以此文总结我的逆向路程以及送给想要学习安卓逆向的新人！！！</strong>  </p>
<hr>
<h2 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h2><hr>
<p><strong>&ensp;&ensp;&ensp;&ensp;逆向这玩意不是很玄学，不像web渗透那样很玄学(强烈吐槽一波以前我还在做web渗透的时候，挖不出大洞也就算了，全都是一堆反射型的xss，xss到底跟我有多过不去啊)，只要你基础够，在舍得掉头发，就能够有产出，下面简单罗列一下我个人认为的安卓逆向所需要的前置技能：</strong>  </p>
<ul>
<li><p><strong>一定程度的安卓正向开发经验</strong>  </p>
</li>
<li><p><strong>会写简单的脚本，例如python、c</strong></p>
</li>
</ul>
<p><strong>&ensp;&ensp;&ensp;&ensp;正向开发越熟练，在逆向的过程越容易找到关键点，同时在正向开发的过程中总要了解一下安卓系统的机制吧，这都是后面的无论是脱壳还是写自己的加固代码必要的知识；至于后面的会写简单的脚本，既是为了逆向也是为了能够正向开发，例如脱壳现在的主流方案要么ida动态调试到脱壳点dump下来，要么使用frida编写脚本hook脱壳，再要么编写xposed插件脱壳（ps:脚本小子除外），这些都需要我们自己写脚本的；至于正向开发那就更没得说了，无论是你想实现自己的加固方案还是要做涉及到底层的开发都需要写到so层里面去，而这前提是你的会c或者c++。至于怎么学，我个人建议去网上找文章教程跟着敲代码就可以了，例如菜鸟教程或w3c！！！</strong>  </p>
<hr>
<h2 id="基础技能"><a href="#基础技能" class="headerlink" title="基础技能"></a>基础技能</h2><hr>
<p><strong>&ensp;&ensp;&ensp;&ensp;说是基础，其实真的是基础，别看看起来真的很难的样子，再安卓逆向的世界里这都是要非常熟练的基础能力，我个人总结如下：</strong>  </p>
<ul>
<li><p><strong>熟练使用AndroidKiller、Jeb等工具</strong>  </p>
</li>
<li><p><strong>了解smali语言，能够将简单的sali语句翻译成java</strong>  </p>
</li>
<li><p><strong>能够使用AndroidStudio进行java层面的动态调试</strong>  </p>
</li>
<li><p><strong>了解arm汇编语言</strong>  </p>
</li>
<li><p><strong>从0到一编写一个so文件</strong>  </p>
</li>
<li><p><strong>能够配合ida对so成进行动态调试并简单了解ida的使用</strong>  </p>
</li>
<li><p><strong>配合so层的编写经验实现自己的反调试代码，并一一动手调试过掉这些反调试</strong></p>
</li>
</ul>
<p><strong>&ensp;&ensp;&ensp;&ensp;我最开始学习这些的时候是大部分跟着52论坛的教我兄弟学逆向教程学的，时间大概两个月左右吧，但有些没有的，例如smali语法，我就去百度搜索和下载官方对应的指令表来学习，学完之后看懂一些简单的语法是没有问题了，还有arm汇编，这个建议去图书馆找本专业书来看，写得比较详细系统，至于其他的，要多动手实践。当然，看雪论坛等这些技术论坛有很多资料，没事就翻一翻，是能够发现惊喜的，有些东西不同时候看是完全不同的，当你在看到能够一下想到原理并知道他下一步要干什么的时候，基本这个知识点你差不多很熟练了，再这个知识点上你也能够被叫声大佬了!!!</strong>  </p>
<hr>
<h2 id="进阶技能"><a href="#进阶技能" class="headerlink" title="进阶技能"></a>进阶技能</h2><hr>
<p><strong>&ensp;&ensp;&ensp;&ensp;在上面基础学完了之后，其实就可以做一些实践了，比如刷一下bugku、攻防世界的题啊，去百度一下一下破解教程，跟着大佬的博客学着破解啊，多练手练着练着就知道一般哪里是逆向的关键点了！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;然后说起进阶技能吧，就是再基础上开始逆向精彩的地方–加固和脱壳之间的对抗，个人总结要学习、研究的知识点有如下：</strong>  </p>
<ul>
<li><p><strong>了解安卓apk包的架构，能解析apk的各种文件，例如dex、xml文件</strong>  </p>
</li>
<li><p><strong>了解动态加载的技术</strong>  </p>
</li>
<li><p><strong>学习安卓第一代壳(落地加载壳)的加固方案然后自己动手实现</strong>  </p>
</li>
<li><p><strong>学习frida的食用方法，会使用frida编写简单的脱壳机</strong>  </p>
</li>
<li><p><strong>有碎片时间可以阅读一下安卓源码</strong>  </p>
</li>
<li><p><strong>学习安卓第二代壳(不落地加载壳)的加固方案有条件就自己实现一下</strong>  </p>
</li>
<li><p><strong>针对第一代壳和第二代壳的加载点无论是使用动态调试还是hook的方法脱壳修复</strong>  </p>
</li>
<li><p><strong>了解第三代壳(函数抽取式壳)和第四代壳(vmp)的原理</strong>  </p>
</li>
<li><p><strong>学会使用或者自己编写针对第三代壳的脱壳机，例如:fart、frida-unpack等等</strong>  </p>
</li>
<li><p><strong>能自己解析so文件，也就是elf文件，这是后面so层加密加固的前提</strong>  </p>
</li>
<li><p><strong>有时间可以学习一下unicorn框架，u1s1，这框架是真的舒服，我记得github上已经有基于unicorn的so调用器，名字叫啥忘了</strong>  </p>
</li>
<li><p><strong>学习so层的一些加密加固方案</strong>  </p>
</li>
<li><p><strong>然后还要ollvm框架，不得不说,ollvm用来对抗ida的分析那滋味是真的酸爽，可以看一下无名侠大佬还有其他大佬写的利用unicorn进行反混淆的文章，是真的棒</strong></p>
</li>
</ul>
<p><strong>&ensp;&ensp;&ensp;&ensp;上面这些是关于加固脱壳我的学习路程，因为个人水平有限，上面可能写的不是很好。我个人始终认为，不会自己写加固代码，就不会真正的脱壳，更不要说修复了，其实，大家写的加固方案加载dex点基本都差不多，你会写了，也知道了加载点再哪儿，脱壳点也就一清二楚了。其他的关于怎么学，可以买书也可以百度大佬们的博客，书我觉得姜维大佬的小黄书和非虫大佬的安卓逆向的书很好，其他的知识点就只有百度和去各大论坛去找资料了！！！</strong>  </p>
<hr>
<h2 id="其他技能"><a href="#其他技能" class="headerlink" title="其他技能"></a>其他技能</h2><hr>
<p><strong>&ensp;&ensp;&ensp;&ensp;当然，除了上面这些跟安卓逆向一看就有直接联系的知识以外，还有很多看似和逆向没那么多的技能，这些看似不重要，但我觉得这些一点都不比加固脱壳的技术的重要性差，例如：</strong>  </p>
<ul>
<li><p><strong>谷歌百度搜索能力和日志分析，安卓逆向这东西你越学的深，遇见问题一般来说都没有现成的解决方案，有的话多半也是商业加密，基本在网上是搜不到的，多谷歌和进行日志分析可能找不到怎么解决，但能找到哪里出现问题，能找到哪里出现问题离解决问题就只有10%了。</strong>  </p>
</li>
<li><p><strong>流量抓取姿势，很多人一听流量抓取就以为这是web渗透做的事，其实不然，app是啥，就是个客户端，和浏览器没什么区别，有时候逆向的时候功能点很多找不到逆向点的时候完全可以靠定位流量锁定关键代码的，当然，在各大厂商日益重视流量安全的今天，抓取流量有时候比较麻烦了，例如，高版本的安卓已经不信任个人https证书，想通过https证书抓取流量在高版本有点行不通了，但是，还是可以通过xposed插件、vpn、更换低版本安卓、hook底层发包函数等方式抓取流量，方法很多，这里只是想说明流量很重要在需要联网的app的逆向过程中。</strong>  </p>
</li>
<li><p><strong>博客书写，写博客不是装逼，不是全写高端的，写博客的本质是总结帮助总结梳理自己的知识体系，写博客只能说仁者见仁智者见智吧！</strong></p>
</li>
</ul>
<p><strong>&ensp;&ensp;&ensp;&ensp;上面写的只是一小部分，这里挑选的是我认为最重要的部分，总之，我觉得要学好安卓逆向，还需要耐得住寂寞，研究这东西真的需要坚持，覆盖的东西太多了！！！</strong>  </p>
<hr>
<h2 id="后序"><a href="#后序" class="headerlink" title="后序"></a>后序</h2><hr>
<p><strong>&ensp;&ensp;&ensp;&ensp;其实还有很多想要写的，但是删了又加，删了又删，就成这样子了，可能写的不是很好，一边写一边回忆自己这一年走过来的艰辛，心绪不是很好，大致上写出来了我自己的学习路线。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;谨以此文总结自己入门安卓逆向的学习，也送给所有对安卓逆向感兴趣的朋友！！！</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/07/16/41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/16/41/" class="post-title-link" itemprop="url">DEX文件解析--7、类及其类数据解析(完结篇)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-16 13:39:41" itemprop="dateCreated datePublished" datetime="2020-07-16T13:39:41+08:00">2020-07-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 22:57:18" itemprop="dateModified" datetime="2024-11-12T22:57:18+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <hr>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p><strong>&ensp;&ensp;&ensp;前置技能链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1057245-1-1.html">DEX文件解析—1、dex文件头解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1070218-1-1.html">DEX文件解析—2、Dex文件checksum(校验和)解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1148568-1-1.html">DEX文件解析–3、dex文件字符串解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1151528-1-1.html">DEX文件解析–4、dex类的类型解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1158006-1-1.html">DEX文件解析–5、dex方法原型解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1159847-1-1.html">DEX文件解析–6、dex文件字段和方法定义解析</a></strong></p>
<p><strong>&ensp;&ensp;&ensp;&ensp;PS：Dex文件解析到现在，终于到了最重要也是结构最复杂的部分了，不了解前面的一些必要知识的，可以看我前面几篇文章；这篇文章分析的dex样本来自一个复杂apk的dex文件，但是代码运行时使用的样本是一个在网上找的很简单的dex样本，原因很简单，分析使用的dex涉及的smali指令太多了，大概有200多个，挨个解析起来工作量太大了，有时间我会写一个通用的python解析模块，完成了我会上传到github仓库，有兴趣的完成后可以看一下，用简单的dex只涉及到5个指令，代码写起来就没那么麻烦了！！！(tips:Dex类数据这里解析起来有种俄罗斯套娃的感觉，多看几篇就很容易理解了。)</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;PS:这篇文章及其之前同系列的整合版(只是所有文章汇总在一起的整合版)都发在某公众号上面了，名字就不说了，怕被认为打广告，所以这不是抄袭哦！！！</strong>  </p>
<hr>
<h1 id="二、uleb128编码"><a href="#二、uleb128编码" class="headerlink" title="二、uleb128编码"></a>二、uleb128编码</h1><p><strong>&ensp;&ensp;&ensp;&ensp;PS:本来关于uleb128编码网上一大堆，没必要写这个，但是网上的你抄我的我抄你的，能找的的相关资料基本都一样。。。。或者干脆贴个官方代码，官方代码的位运算写的很巧妙，但是直接去看的化，反正我是没看懂到底是怎么解码出来的。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;uleb128编码，是一种可变长度的编码，长度大小为<code>1-5字节</code>，uleb128通过字节的最高位来决定是否用到下一个字节，如果最高位为1，则用到下一个字节，直到某个字节最高位为0或已经读取了5个字节为止，接下来通过一个实例来理解uleb128编码。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;假设有以下经过uleb128编码的数据(都为16进制)–<code>81 80 04</code>，首先来看第一个字节<code>81</code>，他的二进制为<code>10000001</code>，他的最高位为<code>1</code>，则说明还要用到下一个字节，它存放的数据则为<code>0000001</code>；再来看第二个字节<code>80</code>，它的二进制为<code>10000000</code>，它的最高位为<code>1</code>，则说明还需要用到第三个字节，存放的数据为<code>0000000</code>；再来看第三个字节<code>04</code>，它的二进制为<code>00000100</code>，最高位为<code>0</code>,说明一共使用了三个字节，它存放的数据为<code>0000100</code>；通过上面的数据我们已经获取了存放的数据，接下来就是把这些bit组合起来获取解码后的数据，dex文件里面的数据都是采用的小端序的方式，uleb128也不例外，在这三个字节，也不例外，第三个字节<code>04</code>存放的数据<code>0000100</code>作为解码后的数据的<code>高7位</code>，第二个字节<code>80</code>存放的数据<code>0000000</code>作为解码后的数据的<code>中7位</code>，第一个字节<code>81</code>存放的数据<code>0000001</code>作为解码后的数据的<code>低7位</code>；那么解码后的数据二进制则为<code>0000100 0000000 0000001</code>，转换为16进制则为<code>0x10001</code>。其他使用5个字节、4个字节照此类推即可，下面是python读取uleb128的代码(ps:该代码是最终类数据解析代码的一共函数，无法单独运行，仅供参考，采用的是官方提供的位运算算法)：</strong>  </p>
<pre><code>def readuleb128(f,addr):
    result = [-1,-1]
    n = 0
    f.seek(addr)
    data = oneByte2Int(f.read(1))
    if data &gt; 0x7f:
        f.seek(addr + 1)
        n = 1
        tmp = oneByte2Int(f.read(1))
        data = (data &amp; 0x7f) | ((tmp &amp; 0x7f) &lt;&lt; 7)
        if tmp &gt; 0x7f:
            f.seek(addr + 2)
            n = 2
            tmp = oneByte2Int(f.read(1))
            data |= (tmp &amp; 0x7f) &lt;&lt; 14
            if tmp &gt; 0x7f:
                f.seek(addr + 3)
                n = 3
                tmp = oneByte2Int(f.read(1))
                data |= (tmp &amp; 0x7f) &lt;&lt; 21
                if tmp &gt; 0x7f:
                    f.seek(addr + 4)
                    n = 4
                    tmp = oneByte2Int(f.read(1))
                    data |= tmp &lt;&lt; 28
    result[0] = data
    result[1] = addr + n + 1
    return result
</code></pre>
<hr>
<h1 id="三、类解析第一层结构：class-def-item"><a href="#三、类解析第一层结构：class-def-item" class="headerlink" title="三、类解析第一层结构：class_def_item"></a>三、类解析第一层结构：class_def_item</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、在dex文件头<code>0x60-0x63</code>这四个字节，指明了<code>class</code>的数量，在<code>0x64-0x67</code>这四个字节，指明的<code>class_def_item</code>的偏移地址。如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、通过上面的偏移地址，我们可以找到class_def_item的起始地址，class_def_item包含了一个类的类名、接口、父类、所属java文件名等信息。一个class_def_item结构大小为32字节，分别包含8个信息，每个信息大小为4字节(小端序存储)：</strong>  </p>
<ul>
<li><code>第1-4字节--class_idx</code>(该值为前面解析出来的类的类型列表的索引，也就是这个类的类名)；  </li>
<li><code>第5-8字节--access_flags</code>（类的访问标志，也就是这个类是public还是private等，这个通过官方的文档查表得知，具体算法在最后面说明）；  </li>
<li><code>第9-12字节--superclass_idx</code>（该值也为前面解析出来的类的类型列表的索引，指明了父类的类名）  </li>
<li><code>第13-16字节--interfaces_off</code>（该值指明了接口信息的偏移地址，所指向的地址结构为typelist，前面的文章有说过，这里不再多说，如果该类没有接口，该值则为0）  </li>
<li><code>第17-20字节--source_file_idx</code>(该值为dex字符串列表的的索引，指明了该类所在的java文件名)  </li>
<li><code>第21-24字节--annotations_off</code>（该值为注释信息的偏移地址，由于注释信息不是我要解析的重点，要查看注释信息具体结构的可以参考官方文档，官方文档地址粘贴在文末）  </li>
<li><code>第25-28字节--class_data_off</code>（该值是这个类数据第二层结构的偏移地址，在该结构中指明了该类的字段和方法）  </li>
<li><code>第29-32字节--static_value_off</code>（该值也是一个偏移地址，指向了一个结构，不是重点，感兴趣的参考官方文档，如果没相关信息，则该值为0）</li>
</ul>
<p><strong>&ensp;&ensp;&ensp;&ensp;具体分析过程，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/2.png">  </p>
<hr>
<h1 id="四、类解析第二层结构：class-data-item"><a href="#四、类解析第二层结构：class-data-item" class="headerlink" title="四、类解析第二层结构：class_data_item"></a>四、类解析第二层结构：class_data_item</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、通过上面class_def_item的分析，我们知道了类的基本信息，例如类名、父类等啊，接下来就是要找到类里面的字段和方法这些信息，而这些信息，在class_def_item里面的class_data_off字段给我们指明<code>class_data_item</code>就包含这些信息并给出了偏移地址，即现在需要解析<code>class_data_iem</code>结构获取字段和方法信息。（ps:以下的数据结构不做特别说明都为uleb128编码格式）</strong><br><strong>&ensp;&ensp;&ensp;&ensp;2、<code>class_data_item</code>结构包含以下信息：</strong>  </p>
<ul>
<li><code>第一个uleb128编码--static_field_size</code>，指明了该类的静态字段的数量</li>
<li><code>第二个uleb128编码--instance_field_size</code>，指明了该类的实例字段的数量（实例字段不知道是啥的建议百度）  </li>
<li><code>第三个uleb128编码--direct_method_size</code>，指明了该类的直接方法的个数</li>
<li><code>第四个uleb128编码--virtual_method_size</code>，指明了该类的虚方法的个数（虚方法理解不清楚的建议百度一下）  </li>
<li><code>encoded_field--static_fields</code>，该结构指明了具体的静态字段信息，该结构的存在前提是<code>static_field_size &gt;0 </code>，该结构包含两个uleb128编码，第一个uleb128编码为前面解析出来的字段列表的索引，第二个uleb128编码指明了该字段的访问标志  </li>
<li><code>encoded_field--instance_fields</code>，跟上面类似，不再多说，值得注意的是，该结构存在的前提是<code>instance_field_size &gt; 0</code>  </li>
<li><code>encoded_method--direct_methods</code>，该结构指明了直接方法具体信息，该结构存在的前提同样是<code>direct_method_size &gt; 0</code>，该结构包含3个uleb128编码，第一个uleb128为前面文章解析出来的方法原型列表的索引值，第二个uleb128编码为该方法的访问标志，第三个uleb128为code_off，也就是该方法具体代码的字节码的偏移地址，对应的结构为code_item，code_item结构里面包含了该方法内部的代码，这里是字节码，也就是smali(ps:如果该方法为抽象方法，例如native方法，这时code_off对应的值为0，即该方法不存在具体代码)  </li>
<li><code>encoded_method--virtual_methods</code>，该结构指明了该类的虚方法的具体信息，存在前提为<code>virtual_method_size &gt; 0</code>，具体结构和上面一样，不再多说<br><strong>&ensp;&ensp;&ensp;&ensp;具体分析过程，如下图所示：</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/3.png">  </p>
<hr>
<h1 id="五、类解析的第三层结构：code-item"><a href="#五、类解析的第三层结构：code-item" class="headerlink" title="五、类解析的第三层结构：code_item"></a>五、类解析的第三层结构：code_item</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、在上面的class_data_item结构中的<code>encoded_method</code>结构的第三个uleb128编码中，指出了一个类中的方法具体代码的偏移地址，也就是dv虚拟机在执行该方法的具体指令的偏移地址，该值指向的地址结构为<code>code_item</code>，里面包含了寄存器数量、具体指令等信息，下面来分析一下该结构。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、<code>code_item</code>结构包含以下信息:</strong>  </p>
<ul>
<li><code>第1-2字节--registers_size</code>，该值指明了该方法使用的寄存器数量，对应的smali语法中的<code>.register</code>的值  </li>
<li><code>第3-4字节--ins_size</code>，该值指明了传入参数的个数  </li>
<li><code>第5-6字节--outs_size</code>，该值指明了该方法内部调用其他函数用到的寄存器个数  </li>
<li><code>第7-8字节--tries_size</code>，该值指明了该方法用到的<code>try-catch</code>语句的个数  </li>
<li><code>第9-12字节--debug_info_off</code>，该值指明了调试信息结构的偏移地址，如果不存在调试信息，则该值为0  </li>
<li><code>第13-16字节--insns_size</code>，该值指明了指令列表的大小，可以这么理解：规定了指令所用的字节数大小–<code>2 x insns_size</code>  </li>
<li><code>ushort[insns_size]--insns</code>，这个是指令列表，包含了该方法所用到的指令的字节，每个指令占用的字节数可以参考官方文档，这个没什么算法，就是一个查表的过程，例如<code>invoke-direct</code>指令占用6个字节，<code>return-void</code>指令占用2个字节  </li>
<li><code>2个字节--padding</code>，该值存在的前提是<code>tries-size &gt; 0</code>，作用用来对齐代码  </li>
<li><code>try_item--tries</code>，该值存在的前提是<code>tries-size &gt; 0</code>，作用是指明异常具体位置和处理方式，该结构不是解析重点，重点是解析指令，感兴趣的查看官方文档  </li>
<li><code>encoded_catch_handler_list--handlers</code>,该结构存在前提为<code>tries-size &gt; 0</code>，同样不是解析重点，感兴趣的查看官方文档</li>
</ul>
<p><strong>&ensp;&ensp;&ensp;&ensp;具体分析过程，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/4.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/5.png">  </p>
<hr>
<h1 id="六、access-flags算法"><a href="#六、access-flags算法" class="headerlink" title="六、access_flags算法"></a>六、access_flags算法</h1><p><strong>&ensp;&ensp;&ensp;&ensp;access_flags访问标志具体值可以去查看官方文档，下图只截了一部分。如果access_flags的算法为<code>access_flags = flag1 | flag2 | ...</code>，如果访问标志只有一共，直接查表即可，如果是两个，按照算法对比值即可，下面举给&#x3D;个例子来理解该算法。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/6.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;例如我有一个类的访问标志为<code>public static</code>，经过查表得知<code>public</code>对应的值为<code>0x01</code>，<code>static</code>对应的值为<code>0x8</code>，那么<code>public static</code>对应的访问标志为<code>0x01 | 0x08 = 0x9</code>，如果读取出来的access_flags为0x09，那么对应的访问标志则为<code>public static</code>，其余的照此算法计算即可！！！</strong>  </p>
<hr>
<h1 id="七、解析代码"><a href="#七、解析代码" class="headerlink" title="七、解析代码"></a>七、解析代码</h1><p><strong>&ensp;&ensp;&ensp;&ensp;PS：代码运行环境推荐3.6及其以上，需要模块<code>binascii</code>，运行样本为<code>Hello.dex</code>，样本附在文末网盘链接中！！！</strong>  </p>
<p><strong>运行截图</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/7.png">  </p>
<p><strong>通过脚本解析出来的和通过apktools反编译出来的smali文件对比图</strong><br><strong>(ps:左侧为apktools反编译出来的，右侧为脚本解析出来的，可以发现基本差不多)</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/8.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_class/9.png">  </p>
<p><strong>解析代码(ps:代码量有点多)：</strong>  </p>
<pre><code>&#39;&#39;&#39;
                                                    __----~~~~~~~~~~~------___
                                .  .   ~~//====......          __--~ ~~
                -.            \_|//     |||\\  ~~~~~~::::... /~
                ___-==_       _-~o~  \/    |||  \\            _/~~-
        __---~~~.==~||\=_    -_--~/_-~|-   |\\   \\        _/~
    _-~~     .=~    |  \\-_    &#39;-~7  /-   /  ||    \      /
.~       .~       |   \\ -_    /  /-   /   ||      \   /
/  ____  /         |     \\ ~-_/  /|- _/   .||       \ /
|~~    ~~|--~~~~--_ \     ~==-/   | \~--===~~        .\
        &#39;         ~-|      /|    |-~\~~       __--~~
                    |-~~-_/ |    |   ~\_   _-~            /\
                        /  \     \__   \/~                \__
                    _--~ _/ | .-~~____--~-/                  ~~==.
                    ((-&gt;/~   &#39;.|||&#39; -_|    ~~-/ ,              . _||
                                -_     ~\      ~~---l__i__i__i--~~_/
                                _-~-__   ~)  \--______________--~~
                            //.-~~~-~_--~- |-------~~~~~~~~
                                    //.-~~~--\
                    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                            神兽保佑            永无BUG

@Author: windy_ll
@Date: 2020-07-08 16:21:27
@LastEditors: windy_ll
@LastEditTime: 2020-07-14 23:45:28
@Description: file content
&#39;&#39;&#39;
import binascii
import re
import os
import sys

def byte2int(bs):
    tmp = bytearray(bs)
    tmp.reverse()
    rl = bytes(tmp)
    rl = str(binascii.b2a_hex(rl),encoding=&#39;UTF-8&#39;)
    rl = int(rl,16)
    return rl

def oneByte2Int(bs):
    num = str(binascii.b2a_hex(bs),encoding=&#39;UTF-8&#39;)
    num = int(num,16)
    return num

def getSmaliName(oldname):
    newname = &#39;&#39;
    tmpname = oldname.split(&#39;.&#39;)
    newname = str(os.path.join(sys.path[0])) + &#39;\\smali\\&#39; + str(tmpname[0]) + &#39;.smali&#39;
    return newname

def readuleb128(f,addr):
    result = [-1,-1]
    n = 0
    f.seek(addr)
    data = oneByte2Int(f.read(1))
    if data &gt; 0x7f:
        f.seek(addr + 1)
        n = 1
        tmp = oneByte2Int(f.read(1))
        data = (data &amp; 0x7f) | ((tmp &amp; 0x7f) &lt;&lt; 7)
        if tmp &gt; 0x7f:
            f.seek(addr + 2)
            n = 2
            tmp = oneByte2Int(f.read(1))
            data |= (tmp &amp; 0x7f) &lt;&lt; 14
            if tmp &gt; 0x7f:
                f.seek(addr + 3)
                n = 3
                tmp = oneByte2Int(f.read(1))
                data |= (tmp &amp; 0x7f) &lt;&lt; 21
                if tmp &gt; 0x7f:
                    f.seek(addr + 4)
                    n = 4
                    tmp = oneByte2Int(f.read(1))
                    data |= tmp &lt;&lt; 28
    result[0] = data
    result[1] = addr + n + 1
    return result

def getAccessFlags(flag):
    accessFlag = &#39;&#39;
    flagList = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x100,0x200,0x400,0x800,0x2000,0x4000,0x10000]
    flagdict = &#123;0x01:&#39;public&#39;,0x02:&#39;private&#39;,0x04:&#39;protected&#39;,0x08:&#39;static&#39;,0x10:&#39;final&#39;,0x20:&#39;synchronized&#39;,0x40:&#39;volatile&#39;,0x80:&#39;transient&#39;,0x100:&#39;native&#39;,\
        0x200:&#39;interface&#39;,0x400:&#39;abstract&#39;,0x800:&#39;strictfp&#39;,0x2000:&#39;annotayion&#39;,0x4000:&#39;enum&#39;,0x10000:&#39;constructor&#39;&#125;
    if flag == 0x1:
        accessFlag = &#39;public&#39;
    elif flag == 0x2:
        accessFlag = &#39;private&#39;
    elif flag == 0x4:
        accessFlag = &#39;protected&#39;
    elif flag == 0x8:
        accessFlag = &#39;static&#39;
    elif flag == 0x10:
        accessFlag = &#39;final&#39;
    elif flag == 0x20:
        accessFlag = &#39;synchronized&#39;
    elif flag == 0x40:
        accessFlag = &#39;volatile&#39;
    elif flag == 0x80:
        accessFlag = &#39;transient&#39;
    elif flag == 0x100:
        accessFlag = &#39;native&#39;
    elif flag == 0x200:
        accessFlag = &#39;interface&#39;
    elif flag == 0x400:
        accessFlag = &#39;abstract&#39;
    elif flag == 0x800:
        accessFlag = &#39;strictfp&#39;
    elif flag == 0x2000:
        accessFlag = flagdict[0x2000]
    elif flag == 0x4000:
        accessFlag = flagdict[0x4000]
    elif flag == 0x10000:
        accessFlag = flagdict[0x10000]
    else:
        mark = 0
        for k in range(14):
            if mark == 1:
                break
            for item in flagList[(k + 1):]:
                if flag == (flagList[k] | item):
                    idx1 = flagList[k]
                    idx2 = item
                    accessFlag = flagdict[idx1] + &#39; &#39; + flagdict[idx2]
                    mark = 1
                    break
    return accessFlag

def parseTypeList(f,addr,tList):
    paramList = []
    f.seek(addr)
    size = byte2int(f.read(4))
    if size == 0:
        return paramList
    else:
        addr = addr + 4
        for k in range(size):
            f.seek(addr + (k * 2))
            paramString = typeList[byte2int(f.read(2))]
            paramList.append(paramString)
    return paramList

def getStringByteArr(f,addr):
    byteArr = bytearray()
    f.seek(addr + 1)
    b = f.read(1)
    b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
    b = int(b,16)
    index = 2
    while b != 0:
        byteArr.append(b)
        f.seek(addr + index)
        b = f.read(1)
        b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
        b = int(b,16)
        index = index + 1
    return byteArr

def BytesToString(byteArr):
    try:
        bs = bytes(byteArr)
        stringItem = str(bs,encoding=&#39;UTF-8&#39;)
        return stringItem
    except:
        pass

def getTypeAmount(f):
    f.seek(0x40)
    stringsId = f.read(4)
    count = byte2int(stringsId)
    return count

def getclassCount(f):
    f.seek(0x60)
    class_num = f.read(4)
    class_size = byte2int(class_num)
    return class_size

def getStringsCount(f):
    f.seek(0x38)
    stringsId = f.read(4)
    count = byte2int(stringsId)
    return count

def getStrings(f,stringAmount):
    stringsList = []
    f.seek(0x3c)
    stringOff = f.read(4)
    Off = byte2int(stringOff)
    f.seek(Off)
    for i in range(stringAmount):
        addr = f.read(4)
        address = byte2int(addr)
        byteArr = getStringByteArr(f,address)
        stringItem = BytesToString(byteArr)
        stringsList.append(stringItem)
        Off = Off + 4
        f.seek(Off)
    return stringsList

def getTypeItem(f,count,strLists):
    typeList = []
    f.seek(0x44)
    type_ids_off = f.read(4)
    type_off = byte2int(type_ids_off)
    f.seek(type_off)
    for i in range(count):
        typeIndex = f.read(4)
        typeIndex = byte2int(typeIndex)
        typeList.append(strLists[typeIndex])
        type_off = type_off + 0x04
        f.seek(type_off)
    return typeList

def parserField(f,stringList,typelist):
    fieldList = []
    f.seek(0x50)
    fieldSize = byte2int(f.read(4))
    fieldAddr = byte2int(f.read(4))
    for i in range(fieldSize):
        fieldStr = &#39;&#39;
        f.seek(fieldAddr)
        classIdx = typelist[byte2int(f.read(2))]
        f.seek(fieldAddr + 2)
        typeIdx = typelist[byte2int(f.read(2))]
        f.seek(fieldAddr + 4)
        nameIdx = stringList[byte2int(f.read(4))]
        fieldAddr += 8
        fieldStr = nameIdx + &#39;:&#39; + typeIdx
        fieldList.append(fieldStr)
    return fieldList

def parseProtold(f,typeList,stringList):
    pList = []
    f.seek(0x48)
    protoldSizeTmp = f.read(4)
    protoldSize = byte2int(protoldSizeTmp)
    f.seek(0x4c)
    protoldAddr = byte2int(f.read(4))
    for i in range(protoldSize):
        f.seek(protoldAddr)
        AllString = stringList[byte2int(f.read(4))]
        protoldAddr += 4
        f.seek(protoldAddr)
        returnString = typeList[byte2int(f.read(4))]
        protoldAddr += 4
        f.seek(protoldAddr)
        paramAddr = byte2int(f.read(4))
        if paramAddr == 0:
            protoldAddr += 4
            pList.append(returnString + &#39;()&#39;)
            continue
        f.seek(paramAddr)
        paramSize = byte2int(f.read(4))
        paramList = []
        if paramSize == 0:
            pass
        else:
            paramAddr = paramAddr + 4
            for k in range(paramSize):
                f.seek(paramAddr + (k * 2))
                paramString = typeList[byte2int(f.read(2))]
                paramList.append(paramString)
        protoldAddr += 4
        paramTmp = []
        for paramItem in paramList:
            paramTmp.append(paramItem)
        param = returnString + &#39;(&#39; + &#39;,&#39;.join(paramTmp) + &#39;)&#39;
        pList.append(param)
    return pList

def parserMethod(f,stringlist,typelist,protoldlist):
    methodlist = []
    f.seek(0x58)
    methodSize = byte2int(f.read(4))
    f.seek(0x5c)
    methodAddr = byte2int(f.read(4))
    for i in range(methodSize):
        f.seek(methodAddr)
        classIdx = typelist[byte2int(f.read(2))]
        f.seek(methodAddr + 2)
        protoldIdx = protoldlist[byte2int(f.read(2))]
        f.seek(methodAddr + 4)
        nameIdx = stringlist[byte2int(f.read(4))]
        tmp = protoldIdx.split(&#39;(&#39;,1)
        methodItem = nameIdx + &#39;(&#39; + str(tmp[1]) + str(tmp[0])
        methodlist.append(methodItem)
        methodAddr += 8
    return methodlist

def parseBytecode(f,addr,bytecount,stringsList,fieldsList,methodsList):
    codestr = &#39;&#39;
    n = 0
    while True:
        f.seek(addr)
        op = byte2int(f.read(1))
        if op == 0x0e:
            codestr += &#39;\treturn-void\r\n&#39;
            addr = addr + 2
            n += 2
        elif op == 0x1a:
            f.seek(addr + 1)
            register = oneByte2Int(f.read(1))
            f.seek(addr + 2)
            idx = byte2int(f.read(2))
            stringIdx = stringsList[idx]
            re.sub(&quot;[\n]&quot;,&quot;&quot;,stringIdx)
            re.sub(&quot;[\r]&quot;,&quot;&quot;,stringIdx)
            codestr += &#39;\tconst-string v&#39; + str(register) + &#39;, &quot;&#39; + stringIdx + &#39;&quot;\r\n&#39;
            addr = addr + 4
            n += 4
        elif op == 0x62:
            f.seek(addr + 1)
            register = oneByte2Int(f.read(1))
            f.seek(addr + 2)
            idx = byte2int(f.read(2))
            codestr += &#39;\tset-object v&#39; + str(register) + &#39;, &#39; + fieldsList[idx] + &#39;\r\n&#39;
            addr = addr + 4
            n += 4
        elif op == 0x70 or op == 0x6e:
            f.seek(addr + 1)
            data = oneByte2Int(f.read(1))
            f.seek(addr + 4)
            data1 = oneByte2Int(f.read(1))
            f.seek(addr + 5)
            data2 = oneByte2Int(f.read(1))
            f.seek(addr + 2)
            idx = byte2int(f.read(2))
            registerNum = (data &amp; 0xf0) &gt;&gt; 4
            register = &#39;&#39;
            if registerNum == 1:
                register_1 = data &amp; 0xf
                register = &#39;&#123;v&#39; + str(register_1) + &#39;&#125;, &#39;
            elif registerNum == 2:
                register_1 = data &amp; 0xf
                register_2 = (data1 &amp; 0xf0) &gt;&gt; 4
                register = &#39;&#123;v&#39; + str(register_1) + &#39;, v&#39; + str(register_2) + &#39;&#125;, &#39;
            elif registerNum == 3:
                register_1 = data &amp; 0xf
                register_2 = (data1 &amp; 0xf0) &gt;&gt; 4
                register_3 = data1 &amp; 0xf
                register = &#39;&#123;v&#39; + str(register_1) + &#39;, v&#39; + str(register_2) + &#39;, v&#39; + str(register_3) + &#39;&#125;, &#39;
            elif registerNum == 4:
                register_1 = data &amp; 0xf
                register_2 = (data1 &amp; 0xf0) &gt;&gt; 4
                register_3 = data1 &amp; 0xf
                register_4 = (data2 &amp; 0xf0) &gt;&gt; 4
                register = &#39;&#123;v&#39; + str(register_1) + &#39;, v&#39; + str(register_2) + &#39;, v&#39; + str(register_3) + &#39;, v&#39; + str(register_4) + &#39;&#125;, &#39;
            else:
                register_1 = data &amp; 0xf
                register_2 = (data1 &amp; 0xf0) &gt;&gt; 4
                register_3 = data1 &amp; 0xf
                register_4 = (data2 &amp; 0xf0) &gt;&gt; 4
                register_5 = data2 &amp; 0xf
                register = &#39;&#123;v&#39; + str(register_1) + &#39;, v&#39; + str(register_2) + &#39;, v&#39; + str(register_3) + &#39;, v&#39; + str(register_4) + &#39;, v&#39; + str(register_5) + &#39;&#125;, &#39;
            if op == 0x70:
                codestr += &#39;\tinvoke-direct &#39; + register + methodsList[idx] + &#39;\r\n&#39;
            else:
                codestr += &#39;\tinvoke-virtual &#39; + register + methodsList[idx] + &#39;\r\n&#39;
            addr = addr + 6
            n += 6
        else:
            pass
        if n == bytecount:
            break
    return codestr


def parseCode(f,addr,fn,slist,flist,mlist):
    f.seek(addr)
    register_size = byte2int(f.read(2))
    f.seek(addr + 2)
    ins_size = byte2int(f.read(2))
    f.seek(addr + 4)
    out_size = byte2int(f.read(2))
    f.seek(addr + 6)
    try_size = byte2int(f.read(2))
    f.seek(addr + 8)
    debug_off = byte2int(f.read(4))
    f.seek(addr + 12)
    insns_size = byte2int(f.read(4))
    address = addr + 16
    bytecount = insns_size * 2
    registerString = &#39;\t.register &#39; + str(register_size) + &#39;\r\n&#39;
    fn.write(registerString)
    codestr = parseBytecode(f,address,bytecount,slist,flist,mlist)
    fn.write(codestr)
    endstr = &#39;.end method\r\n&#39;
    fn.write(endstr)

def parseClassData(f,addr,fn,fList,mList,strsList):
    re = readuleb128(f,addr)
    static_fields_size = re[0]
    address = re[1]
    re = readuleb128(f,address)
    instance_fields_size = re[0]
    address = re[1]
    re = readuleb128(f,address)
    direct_method_size = re[0]
    address = re[1]
    re = readuleb128(f,address)
    virtual_method_size = re[0]
    address = re[1]
    fieldStr = &#39;&#39;
    if static_fields_size != 0:
        fieldStr += &#39;# static fields\r\n&#39;
        for i in range(static_fields_size):
            re = readuleb128(f,address)
            fieldidx = re[0]
            address = re[1]
            re = readuleb128(f,address)
            accflag = re[0]
            address = re[1]
            fieldStr += &#39;.field &#39; + getAccessFlags(accflag) + &#39; &#39; + fList[fieldidx] + &#39;\r\n&#39;
        fieldStr += &#39;\r\n\r\n&#39;
        fn.write(fieldStr)
    fieldStr = &#39;&#39;
    if instance_fields_size != 0:
        fieldStr += &#39;# instance fields\r\n&#39;
        for i in range(instance_fields_size):
            re = readuleb128(f,address)
            fieldidx = re[0]
            address = re[1]
            re = readuleb128(f,address)
            accflag = re[0]
            address = re[1]
            fieldStr += &#39;.field &#39; + getAccessFlags(accflag) + &#39; &#39; + fList[fieldidx] + &#39;\r\n&#39;
        fieldStr += &#39;\r\n\r\n&#39;
        fn.write(fieldStr)
    methodStr = &#39;&#39;
    if direct_method_size != 0:
        methodStr += &#39;# direct methods\r\n&#39;
        fn.write(methodStr)
        for i in range(direct_method_size):
            re = readuleb128(f,address)
            methodidx = re[0]
            address = re[1]
            re = readuleb128(f,address)
            accflag = re[0]
            address = re[1]
            re = readuleb128(f,address)
            code_off = re[0]
            address = re[1]
            methodStr = &#39;.method &#39; + getAccessFlags(accflag) + &#39; &#39; + mList[methodidx] + &#39;\r\n&#39;
            fn.write(methodStr)
            parseCode(f,code_off,fn,strsList,fList,mList)
        methodStr = &#39;\r\n\r\n&#39;
        fn.write(methodStr)
    methodStr = &#39;&#39;
    if virtual_method_size != 0:
        methodStr = &#39;# virtual methods\r\n&#39;
        fn.write(methodStr)
        for i in range(virtual_method_size):
            re = readuleb128(f,address)
            methodidx = re[0]
            address = re[1]
            re = readuleb128(f,address)
            accflag = re[0]
            address = re[1]
            re = readuleb128(f,address)
            code_off = re[0]
            address = re[1]
            methodStr = &#39;.method &#39; + getAccessFlags(accflag) + &#39; &#39; + mList[methodidx] + &#39;\r\n&#39;
            fn.write(methodStr)
            parseCode(f,code_off,fn,strsList,fList,mList)
        methodStr = &#39;\r\n\r\n&#39;
        fn.write(methodStr)

def parseClassDefItem(f,class_num,tList,sList,fieldlist,methodlist):
    f.seek(0x64)
    addr = byte2int(f.read(4))
    for i in range(class_num):
        f.seek(addr)
        classIdx = tList[byte2int(f.read(4))]
        f.seek(addr + 4)
        accessFlags = getAccessFlags(byte2int(f.read(4)))
        if accessFlags != &#39;error&#39;:
            pass
        f.seek(addr + 8)
        superclass_idx = tList[byte2int(f.read(4))]
        f.seek(addr + 12)
        interfaces_off = byte2int(f.read(4))
        if interfaces_off == 0:
            pass
        else:
            parseTypeList(f,interfaces_off,tList)
        f.seek(addr + 16)
        sourceFileIdx = sList[byte2int(f.read(4))]
        f.seek(addr + 20)
        annotions_off = byte2int(f.read(4))
        address = 0
        f.seek(addr + 24)
        class_data_off = byte2int(f.read(4))
        f.seek(addr + 28)
        static_value_off = byte2int(f.read(4))
        fname = getSmaliName(sourceFileIdx)
        fn = open(fname,&#39;a+&#39;,True)
        headstr = &#39;.class &#39; + str(accessFlags) + &#39; &#39; + str(classIdx) + &#39;\r\n&#39;
        headstr += &#39;.super &#39; + str(superclass_idx) + &#39;\r\n&#39;
        headstr += &#39;.source &#39; + &#39;&quot;&#39; + str(sourceFileIdx) + &#39;&quot;\r\n\r\n&#39;
        fn.write(headstr)
        if class_data_off != 0:
            parseClassData(f,class_data_off,fn,fieldlist,methodlist,sList)
        fn.close()
        print(&#39;[*] %s文件的类%s写入完毕！&#39;%(fname,classIdx))
        addr += 32


if __name__ == &#39;__main__&#39;:
    filename = str(os.path.join(sys.path[0])) + &#39;\\Hello.dex&#39;
    dir = str(os.path.join(sys.path[0])) + &#39;\\smali&#39;
    if not os.path.exists(dir):
        os.makedirs(dir)
    f = open(filename,&#39;rb&#39;,True)
    stringsCount = getStringsCount(f)
    strList = getStrings(f,stringsCount)
    typeCount = getTypeAmount(f)
    typeList = getTypeItem(f,typeCount,strList)
    fieldList = parserField(f,strList,typeList)
    protoldList = parseProtold(f,typeList,strList)
    methodList = parserMethod(f,strList,typeList,protoldList)
    classNum = getclassCount(f)
    parseClassDefItem(f,classNum,typeList,strList,fieldList,methodList)
    f.close()
</code></pre>
<hr>
<h1 id="八、参考资料以及样本下载"><a href="#八、参考资料以及样本下载" class="headerlink" title="八、参考资料以及样本下载"></a>八、参考资料以及样本下载</h1><p><strong>参考资料：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;1、Android逆向之旅—解析编译之后的Dex文件格式:<a target="_blank" rel="noopener" href="http://www.520monkey.com/archives/579">http://www.520monkey.com/archives/579</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;2、一篇文章带你搞懂DEX文件的结构:<a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_18268881/article/details/55832757">https://blog.csdn.net/sinat_18268881&#x2F;article&#x2F;details&#x2F;55832757</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;3、官方文档:<a target="_blank" rel="noopener" href="https://source.android.google.cn/devices/tech/dalvik/dex-format#embedded-in-class_def_item,-encoded_field,-encoded_method,-and-innerclass">https://source.android.google.cn/devices/tech/dalvik/dex-format#embedded-in-class_def_item,-encoded_field,-encoded_method,-and-innerclass</a></strong>  </p>
<p><strong>样本及代码下载：</strong><br><strong>蓝奏云链接：<a target="_blank" rel="noopener" href="https://wws.lanzous.com/iG8Cuemlw4d">https://wws.lanzous.com/iG8Cuemlw4d</a>；密码：chb6</strong><br><strong>github链接：<a target="_blank" rel="noopener" href="https://github.com/windy-purple/parserDex">https://github.com/windy-purple/parserDex</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/04/18/35/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/18/35/" class="post-title-link" itemprop="url">DEX文件解析--6、dex文件字段和方法定义解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-18 20:00:35" itemprop="dateCreated datePublished" datetime="2020-04-18T20:00:35+08:00">2020-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 22:54:31" itemprop="dateModified" datetime="2024-11-12T22:54:31+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>18 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p><strong>&ensp;&ensp;&ensp;前几篇文章链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1057245-1-1.html">DEX文件解析—1、dex文件头解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1070218-1-1.html">DEX文件解析—2、Dex文件checksum(校验和)解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1148568-1-1.html">DEX文件解析–3、dex文件字符串解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1151528-1-1.html">DEX文件解析–4、dex类的类型解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1158006-1-1.html">DEX文件解析–5、dex方法原型解析</a></strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;PS：阅读之前，最好知道关于dex文件字符串、类的类型以及方法原型是怎么解析出来的！！！</strong>  </p>
<hr>
<h1 id="二、Dex文件中的字段"><a href="#二、Dex文件中的字段" class="headerlink" title="二、Dex文件中的字段"></a>二、Dex文件中的字段</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、在dex文件头中，关于字段（ps:字段可以简单理解成定义的变量或者常量）相关的信息有8个字节，在<code>0x50~0x53</code>这四个字节，按小端序存储这dex文件中的字段数量，在<code>0x54~0x57</code>这四个字节，存储这读取字段的起始偏移地址，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_field/5.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、根据上面的字段起始偏移地址，我们可以找到字段，表示一个字段需要用八个字节，其中，前两个字节为我们在前面解析出来类的类型列表的索引，通过该索引找到的类的类型表示该字段在该类中被定义的（ps：我是这么理解的，如有不对，还请纠正）；第三个字节和第四个字节，也是类的类型列表的索引，表示该字段的类型，例如我们在java某个类中定义了一个变量<code>int a</code>，那么我们此处解析出来的字段类型就是<code>int</code>；最后四个字节，则是我们前面解析出来字符串列表的索引，通过该索引找到的字符串表示字段的，例如我们定义了一个变量<code>String test;</code>，那么我们在这里解析出来的就是<code>test</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_field/6.png">  </p>
<p><strong>解析代码运行截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_field/1.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_field/2.png">  </p>
<p><strong>解析代码：</strong>  </p>
<pre><code>import binascii
import os
import sys

def byte2int(bs):
    tmp = bytearray(bs)
    tmp.reverse()
    rl = bytes(tmp)
    rl = str(binascii.b2a_hex(rl),encoding=&#39;UTF-8&#39;)
    rl = int(rl,16)
    return rl

def getStringsCount(f):
    f.seek(0x38)
    stringsId = f.read(4)
    count = byte2int(stringsId)
    return count

def getStringByteArr(f,addr):
    byteArr = bytearray()
    f.seek(addr + 1)
    b = f.read(1)
    b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
    b = int(b,16)
    index = 2
    while b != 0:
        byteArr.append(b)
        f.seek(addr + index)
        b = f.read(1)
        b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
        b = int(b,16)
        index = index + 1
    return byteArr

def BytesToString(byteArr):
    try:
        bs = bytes(byteArr)
        stringItem = str(bs,encoding=&#39;UTF-8&#39;)
        return stringItem
    except:
        pass

def getAddress(addr):
    address = bytearray(addr)
    address.reverse()
    address = bytes(address)
    address = str(binascii.b2a_hex(address),encoding=&#39;UTF-8&#39;)
    address = int(address,16)
    return address

def getStrings(f,stringAmount):
    stringsList = []
    f.seek(0x3c)
    stringOff = f.read(4)
    Off = getAddress(stringOff)
    f.seek(Off)
    for i in range(stringAmount):
        addr = f.read(4)
        address = getAddress(addr)
        byteArr = getStringByteArr(f,address)
        stringItem = BytesToString(byteArr)
        stringsList.append(stringItem)
        Off = Off + 4
        f.seek(Off)
    return stringsList

def getTypeAmount(f):
    f.seek(0x40)
    stringsId = f.read(4)
    count = byte2int(stringsId)
    return count

def getTypeItem(f,count,strLists):
    typeList = []
    f.seek(0x44)
    type_ids_off = f.read(4)
    type_off = byte2int(type_ids_off)
    f.seek(type_off)
    for i in range(count):
        typeIndex = f.read(4)
        typeIndex = byte2int(typeIndex)
        typeList.append(strLists[typeIndex])
        type_off = type_off + 0x04
        f.seek(type_off)
    return typeList

def changeDisplay(viewString):
    display = &#39;&#39;
    if viewString == &#39;V&#39;:
        display = &#39;void&#39;
    elif viewString == &#39;Z&#39;:
        display = &#39;boolean&#39;
    elif viewString == &#39;B&#39;:
        display = &#39;byte&#39;
    elif viewString == &#39;S&#39;:
        display = &#39;short&#39;
    elif viewString == &#39;C&#39;:
        display = &#39;char&#39;
    elif viewString == &#39;I&#39;:
        display = &#39;int&#39;
    elif viewString == &#39;J&#39;:
        display = &#39;long&#39;
    elif viewString == &#39;F&#39;:
        display = &#39;float&#39;
    elif viewString == &#39;D&#39;:
        display = &#39;double&#39;
    elif viewString[0:1] == &#39;L&#39;:
        display = viewString[1:-1]
    elif viewString[0:1] == &#39;[&#39;:
        if viewString[1:2] == &#39;L&#39;:
            display = viewString[2:-1] + &#39;[]&#39;
        else:
            if viewString[1:] == &#39;Z&#39;:
                display = &#39;boolean[]&#39;
            elif viewString[1:] == &#39;B&#39;:
                display = &#39;byte[]&#39;
            elif viewString[1:] == &#39;S&#39;:
                display = &#39;short[]&#39;
            elif viewString[1:] == &#39;C&#39;:
                display = &#39;char[]&#39;
            elif viewString[1:] == &#39;I&#39;:
                display = &#39;int[]&#39;
            elif viewString[1:] == &#39;J&#39;:
                display = &#39;long[]&#39;
            elif viewString[1:] == &#39;F&#39;:
                display = &#39;float[]&#39;
            elif viewString[1:] == &#39;D&#39;:
                display = &#39;double[]&#39;
            else:
                display = &#39;&#39;
    else:
        display = &#39;&#39;
    return display

def parserField(f,stringList,typelist):
    fieldList = []
    f.seek(0x50)
    fieldSize = byte2int(f.read(4))
    print(&#39;[+] field size ==&gt; &#39;,end=&#39;&#39;)
    print(fieldSize)
    fieldAddr = byte2int(f.read(4))
    for i in range(fieldSize):
        fieldStr = &#39;&#39;
        f.seek(fieldAddr)
        classIdx = typelist[byte2int(f.read(2))]
        f.seek(fieldAddr + 2)
        typeIdx = typelist[byte2int(f.read(2))]
        f.seek(fieldAddr + 4)
        nameIdx = stringList[byte2int(f.read(4))]
        fieldAddr += 8
        fieldStr = changeDisplay(typeIdx) + &#39; &#39; + changeDisplay(classIdx) + &#39;.&#39; + nameIdx
        fieldList.append(fieldStr)
    
    k = 0

    for fieldItem in fieldList:
        print(f&#39;[-] fieldId[&#123;k&#125;] ==&gt; &#39;,end=&#39;&#39;)
        print(fieldItem)
        k += 1


if __name__ == &#39;__main__&#39;:
    filename = str(os.path.join(sys.path[0])) + &#39;\\1.dex&#39;
    f = open(filename,&#39;rb&#39;,True)
    stringsCount = getStringsCount(f)
    strList = getStrings(f,stringsCount)
    typeCount = getTypeAmount(f)
    typeList = getTypeItem(f,typeCount,strList)
    parserField(f,strList,typeList)
    f.close()
</code></pre>
<hr>
<h1 id="三、Dex文件中的方法定义"><a href="#三、Dex文件中的方法定义" class="headerlink" title="三、Dex文件中的方法定义"></a>三、Dex文件中的方法定义</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、在dex文件头中，关于方法定义的信息同样是八个字节，分别位于<code>0x58</code>处和<code>0x5c</code>处。在<code>0x58</code>处的四个字节，指明了dex文件中方法定义的数量，在<code>0x5c</code>处的四个字节，表明了dex文件中的方法定义的起始地址（ps：都是以小端序存储的），如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_field/7.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、在上面的一步以及找到了方法定义的起始地址，跟字段类似的，一个方法定义也需要八个字节。其中，在前两个字节，以小端序存储着解析出来的类的类型列表的索引，表示该方法属于哪个类；第三个字节和第四个字节，以小端序存储这解析出来的方法原型列表的索引，通过该索引值找到的方法原型声明了该方法的返回值类型和参数类型；最后四个字节则以小端序存储着前面解析出来的字符串列表的索引，声明了该方法的方法名。如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_field/8.png">  </p>
<p><strong>解析代码运行截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_field/3.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_field/4.png">  </p>
<p><strong>解析代码：</strong>  </p>
<pre><code>import binascii
import os
import sys

def byte2int(bs):
    tmp = bytearray(bs)
    tmp.reverse()
    rl = bytes(tmp)
    rl = str(binascii.b2a_hex(rl),encoding=&#39;UTF-8&#39;)
    rl = int(rl,16)
    return rl

def getStringsCount(f):
    f.seek(0x38)
    stringsId = f.read(4)
    count = byte2int(stringsId)
    return count

def getStringByteArr(f,addr):
    byteArr = bytearray()
    f.seek(addr + 1)
    b = f.read(1)
    b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
    b = int(b,16)
    index = 2
    while b != 0:
        byteArr.append(b)
        f.seek(addr + index)
        b = f.read(1)
        b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
        b = int(b,16)
        index = index + 1
    return byteArr

def BytesToString(byteArr):
    try:
        bs = bytes(byteArr)
        stringItem = str(bs,encoding=&#39;UTF-8&#39;)
        return stringItem
    except:
        pass

def getAddress(addr):
    address = bytearray(addr)
    address.reverse()
    address = bytes(address)
    address = str(binascii.b2a_hex(address),encoding=&#39;UTF-8&#39;)
    address = int(address,16)
    return address

def getStrings(f,stringAmount):
    stringsList = []
    f.seek(0x3c)
    stringOff = f.read(4)
    Off = getAddress(stringOff)
    f.seek(Off)
    for i in range(stringAmount):
        addr = f.read(4)
        address = getAddress(addr)
        byteArr = getStringByteArr(f,address)
        stringItem = BytesToString(byteArr)
        stringsList.append(stringItem)
        Off = Off + 4
        f.seek(Off)
    return stringsList

def getTypeAmount(f):
    f.seek(0x40)
    stringsId = f.read(4)
    count = byte2int(stringsId)
    return count

def getTypeItem(f,count,strLists):
    typeList = []
    f.seek(0x44)
    type_ids_off = f.read(4)
    type_off = byte2int(type_ids_off)
    f.seek(type_off)
    for i in range(count):
        typeIndex = f.read(4)
        typeIndex = byte2int(typeIndex)
        typeList.append(strLists[typeIndex])
        type_off = type_off + 0x04
        f.seek(type_off)
    return typeList

def changeDisplay(viewString):
    display = &#39;&#39;
    if viewString == &#39;V&#39;:
        display = &#39;void&#39;
    elif viewString == &#39;Z&#39;:
        display = &#39;boolean&#39;
    elif viewString == &#39;B&#39;:
        display = &#39;byte&#39;
    elif viewString == &#39;S&#39;:
        display = &#39;short&#39;
    elif viewString == &#39;C&#39;:
        display = &#39;char&#39;
    elif viewString == &#39;I&#39;:
        display = &#39;int&#39;
    elif viewString == &#39;J&#39;:
        display = &#39;long&#39;
    elif viewString == &#39;F&#39;:
        display = &#39;float&#39;
    elif viewString == &#39;D&#39;:
        display = &#39;double&#39;
    elif viewString[0:1] == &#39;L&#39;:
        display = viewString[1:-1]
    elif viewString[0:1] == &#39;[&#39;:
        if viewString[1:2] == &#39;L&#39;:
            display = viewString[2:-1] + &#39;[]&#39;
        else:
            if viewString[1:] == &#39;Z&#39;:
                display = &#39;boolean[]&#39;
            elif viewString[1:] == &#39;B&#39;:
                display = &#39;byte[]&#39;
            elif viewString[1:] == &#39;S&#39;:
                display = &#39;short[]&#39;
            elif viewString[1:] == &#39;C&#39;:
                display = &#39;char[]&#39;
            elif viewString[1:] == &#39;I&#39;:
                display = &#39;int[]&#39;
            elif viewString[1:] == &#39;J&#39;:
                display = &#39;long[]&#39;
            elif viewString[1:] == &#39;F&#39;:
                display = &#39;float[]&#39;
            elif viewString[1:] == &#39;D&#39;:
                display = &#39;double[]&#39;
            else:
                display = &#39;&#39;
    else:
        display = &#39;&#39;
    return display

def parseProtold(f,typeList,stringList):
    pList = []
    f.seek(0x48)
    protoldSizeTmp = f.read(4)
    protoldSize = byte2int(protoldSizeTmp)
    f.seek(0x4c)
    protoldAddr = byte2int(f.read(4))
    for i in range(protoldSize):
        f.seek(protoldAddr)
        AllString = stringList[byte2int(f.read(4))]
        protoldAddr += 4
        f.seek(protoldAddr)
        returnString = typeList[byte2int(f.read(4))]
        protoldAddr += 4
        f.seek(protoldAddr)
        paramAddr = byte2int(f.read(4))
        if paramAddr == 0:
            protoldAddr += 4
            pList.append(changeDisplay(returnString) + &#39;()&#39;)
            continue
        f.seek(paramAddr)
        paramSize = byte2int(f.read(4))
        paramList = []
        if paramSize == 0:
            pass
        else:
            paramAddr = paramAddr + 4
            for k in range(paramSize):
                f.seek(paramAddr + (k * 2))
                paramString = typeList[byte2int(f.read(2))]
                paramList.append(paramString)
        protoldAddr += 4
        paramTmp = []
        for paramItem in paramList:
            paramTmp.append(changeDisplay(paramItem))
        param = changeDisplay(returnString) + &#39;(&#39; + &#39;,&#39;.join(paramTmp) + &#39;)&#39;
        pList.append(param)
    return pList

def parserMethod(f,stringlist,typelist,protoldlist):
    methodlist = []
    f.seek(0x58)
    methodSize = byte2int(f.read(4))
    print(&#39;[+] method size ==&gt; &#39;,end=&#39;&#39;)
    print(methodSize)
    f.seek(0x5c)
    methodAddr = byte2int(f.read(4))
    for i in range(methodSize):
        f.seek(methodAddr)
        classIdx = typelist[byte2int(f.read(2))]
        f.seek(methodAddr + 2)
        protoldIdx = protoldlist[byte2int(f.read(2))]
        f.seek(methodAddr + 4)
        nameIdx = stringlist[byte2int(f.read(4))]
        tmp = protoldIdx.split(&#39;(&#39;,1)
        methodItem = str(tmp[0]) + &#39; &#39; + classIdx + &#39;.&#39; + nameIdx + &#39;(&#39; + str(tmp[1])
        methodlist.append(methodItem)
        print(f&#39;[-] method[&#123;i&#125;] ==&gt; &#39;,end=&#39;&#39;)
        print(methodItem)
        methodAddr += 8


if __name__ == &#39;__main__&#39;:
    filename = str(os.path.join(sys.path[0])) + &#39;\\1.dex&#39;
    f = open(filename,&#39;rb&#39;,True)
    stringsCount = getStringsCount(f)
    strList = getStrings(f,stringsCount)
    typeCount = getTypeAmount(f)
    typeList = getTypeItem(f,typeCount,strList)
    protoldList = parseProtold(f,typeList,strList)
    parserMethod(f,strList,typeList,protoldList)
    f.close()
</code></pre>
<hr>
<h1 id="四、样本及代码下载链接和一些总结"><a href="#四、样本及代码下载链接和一些总结" class="headerlink" title="四、样本及代码下载链接和一些总结"></a>四、样本及代码下载链接和一些总结</h1><p><strong>&ensp;&ensp;1、没什么好总结的，需要说明的是上面所有代码我电脑运行环境为python3.6。</strong><br><strong>&ensp;&ensp;2、下载链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;百度网盘链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qBgyy5b6Kw2GOmEY9idKqQ">https://pan.baidu.com/s/1qBgyy5b6Kw2GOmEY9idKqQ</a>，提取码：u2ux</strong>  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/04/16/03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/16/03/" class="post-title-link" itemprop="url">DEX文件解析--5、dex方法原型解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-16 15:25:03" itemprop="dateCreated datePublished" datetime="2020-04-16T15:25:03+08:00">2020-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 22:53:07" itemprop="dateModified" datetime="2024-11-12T22:53:07+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>10 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p><strong>&ensp;&ensp;&ensp;前几篇文章链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1057245-1-1.html">DEX文件解析—1、dex文件头解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1070218-1-1.html">DEX文件解析—2、Dex文件checksum(校验和)解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1148568-1-1.html">DEX文件解析–3、dex文件字符串解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1151528-1-1.html">DEX文件解析–4、dex类的类型解析</a></strong>  </p>
<hr>
<h1 id="二、DEX文件中的方法原型"><a href="#二、DEX文件中的方法原型" class="headerlink" title="二、DEX文件中的方法原型"></a>二、DEX文件中的方法原型</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、关于dex文件中方法原型的解析，需要知道怎么解析出字符串和类的类型，不明白的可以看我前几篇的解析。DEX文件中的方法原型定义了一个方法的返回值类型和参数类型，例如一个方法返回值为<code>void</code>，参数类型为<code>int</code>，那么在dex文件中该方法原型表示为<code>V(I)</code>(<code>smali</code>中<code>V</code>表示<code>void</code>，<code>I</code>表示<code>int</code>)。在dex文件头部中，关于方法原型有两处，第一处位于<code>0x48</code>处，用4个字节定义了方法原型的数量，在<code>0x4C</code>处用4个字节定义了方法原型的偏移地址，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_protold/3.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、在上面我们知道了方法原型的起始偏移地址，接下来我们根据这个偏移地址找到方法原型，同样的，跟解析类的类型比较类似，一个方法原型所占字节数为12个字节，第一个字节到第四个字节表示了定义方法原型的字符串，这四个字节按小端序存储，读取出来为在字符串列表的索引，例如一个方法原型返回值为<code>void</code>，参数为<code>boolean</code>，那么定义该方法原型的字符串即为<code>VZ</code>；第5个字节到第八个字节表示该方法原型的返回值类型，读取出来的值为前面解析出来的类的类型列表的索引；第8个字节到第十二给字节表示该方法原型的参数，读取出来为一组地址，通过该地址可以找到该方法原型的参数，跳转到该地址去，首先看前4个字节，前四个字节按照小端序存储，读取出来的值为该方法原型参数的个数，接着根据参数个数，读取具体的参数类型，每个参数类型占2个字节，这两个字节读取出来的值为前面解析出来的类的类型列表的索引，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_protold/4.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_protold/5.png">  </p>
<hr>
<h1 id="三、解析代码"><a href="#三、解析代码" class="headerlink" title="三、解析代码"></a>三、解析代码</h1><p><strong>&ensp;运行环境：我电脑环境为python3.6</strong><br><strong>&ensp;运行截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_protold/1.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_protold/2.png">  </p>
<p><strong>解析代码：</strong>  </p>
<pre><code>import binascii
import os
import sys

def byte2int(bs):
    tmp = bytearray(bs)
    tmp.reverse()
    rl = bytes(tmp)
    rl = str(binascii.b2a_hex(rl),encoding=&#39;UTF-8&#39;)
    rl = int(rl,16)
    return rl

def getStringsCount(f):
    f.seek(0x38)
    stringsId = f.read(4)
    count = byte2int(stringsId)
    return count

def getStringByteArr(f,addr):
    byteArr = bytearray()
    f.seek(addr + 1)
    b = f.read(1)
    b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
    b = int(b,16)
    index = 2
    while b != 0:
        byteArr.append(b)
        f.seek(addr + index)
        b = f.read(1)
        b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
        b = int(b,16)
        index = index + 1
    return byteArr

def BytesToString(byteArr):
    try:
        bs = bytes(byteArr)
        stringItem = str(bs,encoding=&#39;UTF-8&#39;)
        return stringItem
    except:
        pass

def getAddress(addr):
    address = bytearray(addr)
    address.reverse()
    address = bytes(address)
    address = str(binascii.b2a_hex(address),encoding=&#39;UTF-8&#39;)
    address = int(address,16)
    return address

def getStrings(f,stringAmount):
    stringsList = []
    f.seek(0x3c)
    stringOff = f.read(4)
    Off = getAddress(stringOff)
    f.seek(Off)
    for i in range(stringAmount):
        addr = f.read(4)
        address = getAddress(addr)
        byteArr = getStringByteArr(f,address)
        stringItem = BytesToString(byteArr)
        stringsList.append(stringItem)
        Off = Off + 4
        f.seek(Off)
    return stringsList

def getTypeAmount(f):
    f.seek(0x40)
    stringsId = f.read(4)
    count = byte2int(stringsId)
    return count

def getTypeItem(f,count,strLists):
    typeList = []
    f.seek(0x44)
    type_ids_off = f.read(4)
    type_off = byte2int(type_ids_off)
    f.seek(type_off)
    for i in range(count):
        typeIndex = f.read(4)
        typeIndex = byte2int(typeIndex)
        typeList.append(strLists[typeIndex])
        type_off = type_off + 0x04
        f.seek(type_off)
    return typeList

def changeDisplay(viewString):
    display = &#39;&#39;
    if viewString == &#39;V&#39;:
        display = &#39;void&#39;
    elif viewString == &#39;Z&#39;:
        display = &#39;boolean&#39;
    elif viewString == &#39;B&#39;:
        display = &#39;byte&#39;
    elif viewString == &#39;S&#39;:
        display = &#39;short&#39;
    elif viewString == &#39;C&#39;:
        display = &#39;char&#39;
    elif viewString == &#39;I&#39;:
        display = &#39;int&#39;
    elif viewString == &#39;J&#39;:
        display = &#39;long&#39;
    elif viewString == &#39;F&#39;:
        display = &#39;float&#39;
    elif viewString == &#39;D&#39;:
        display = &#39;double&#39;
    elif viewString[0:1] == &#39;L&#39;:
        display = viewString[1:-1]
    elif viewString[0:1] == &#39;[&#39;:
        if viewString[1:2] == &#39;L&#39;:
            display = viewString[2:-1] + &#39;[]&#39;
        else:
            if viewString[1:] == &#39;Z&#39;:
                display = &#39;boolean[]&#39;
            elif viewString[1:] == &#39;B&#39;:
                display = &#39;byte[]&#39;
            elif viewString[1:] == &#39;S&#39;:
                display = &#39;short[]&#39;
            elif viewString[1:] == &#39;C&#39;:
                display = &#39;char[]&#39;
            elif viewString[1:] == &#39;I&#39;:
                display = &#39;int[]&#39;
            elif viewString[1:] == &#39;J&#39;:
                display = &#39;long[]&#39;
            elif viewString[1:] == &#39;F&#39;:
                display = &#39;float[]&#39;
            elif viewString[1:] == &#39;D&#39;:
                display = &#39;double[]&#39;
            else:
                display = &#39;&#39;
    else:
        display = &#39;&#39;
    return display

def parseProtold(f,typeList,stringList):
    f.seek(0x48)
    protoldSizeTmp = f.read(4)
    protoldSize = byte2int(protoldSizeTmp)
    print(&#39;[+] protold size ==&gt; &#39;,end=&#39;&#39;)
    print(protoldSize)
    f.seek(0x4c)
    protoldAddr = byte2int(f.read(4))
    for i in range(protoldSize):
        f.seek(protoldAddr)
        AllString = stringList[byte2int(f.read(4))]
        protoldAddr += 4
        f.seek(protoldAddr)
        returnString = typeList[byte2int(f.read(4))]
        protoldAddr += 4
        f.seek(protoldAddr)
        paramAddr = byte2int(f.read(4))
        if paramAddr == 0:
            protoldAddr += 4
            print(f&#39;[-] protold[&#123;i&#125;] ==&gt; &#39;,end=&#39;&#39;)
            print(AllString + &#39; : &#39;,end=&#39;&#39;)
            print(changeDisplay(returnString) + &#39;()&#39;)
            continue
        f.seek(paramAddr)
        paramSize = byte2int(f.read(4))
        paramList = []
        if paramSize == 0:
            pass
        else:
            paramAddr = paramAddr + 4
            for k in range(paramSize):
                f.seek(paramAddr + (k * 2))
                paramString = typeList[byte2int(f.read(2))]
                paramList.append(paramString)
        protoldAddr += 4
        paramTmp = []
        for paramItem in paramList:
            paramTmp.append(changeDisplay(paramItem))
        print(f&#39;[-] protold[&#123;i&#125;] ==&gt; &#39;,end=&#39;&#39;)
        print(AllString + &#39; : &#39;,end=&#39;&#39;)
        print(changeDisplay(returnString) + &#39;(&#39;,end=&#39;&#39;)
        param = &#39;,&#39;.join(paramTmp)
        print(param + &#39;)&#39;)

if __name__ == &#39;__main__&#39;:
    filename = str(os.path.join(sys.path[0])) + &#39;\\1.dex&#39;
    f = open(filename,&#39;rb&#39;,True)
    stringsCount = getStringsCount(f)
    strList = getStrings(f,stringsCount)
    typeCount = getTypeAmount(f)
    typeList = getTypeItem(f,typeCount,strList)
    parseProtold(f,typeList,strList)
    f.close()
</code></pre>
<hr>
<h1 id="四、相关链接以及样本代码下载加总结"><a href="#四、相关链接以及样本代码下载加总结" class="headerlink" title="四、相关链接以及样本代码下载加总结"></a>四、相关链接以及样本代码下载加总结</h1><p><strong>&ensp;&ensp;1、总结：没啥可以总结的，就是代码写的比较丑，大佬勿喷！！！</strong>  </p>
<p><strong>&ensp;&ensp;2、smali数据格式参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ls0111/article/details/76228068">https://blog.csdn.net/ls0111/article/details/76228068</a></strong>  </p>
<p><strong>&ensp;&ensp;3、样本及代码下载链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;百度网盘:<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1dF-V7oSoXv_shYw7GlP84A">https://pan.baidu.com/s/1dF-V7oSoXv_shYw7GlP84A</a>，提取码：wzdu</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/04/08/00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/08/00/" class="post-title-link" itemprop="url">DEX文件解析--4、dex类的类型解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-08 17:09:00" itemprop="dateCreated datePublished" datetime="2020-04-08T17:09:00+08:00">2020-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 22:47:23" itemprop="dateModified" datetime="2024-11-12T22:47:23+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p><strong>&ensp;&ensp;前几篇系列文章链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1057245-1-1.html">DEX文件解析—1、dex文件头解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1070218-1-1.html">DEX文件解析—2、Dex文件checksum(校验和)解析</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1148568-1-1.html">DEX文件解析–3、dex文件字符串解析</a></strong>  </p>
<hr>
<h1 id="二、DEX文件中的类的类型"><a href="#二、DEX文件中的类的类型" class="headerlink" title="二、DEX文件中的类的类型"></a>二、DEX文件中的类的类型</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、Dex文件中关于类的类型需要知道字符串是怎么解析的，如果不知道的，可以看一下我的上一篇文章。好了，切入正题，关于类的类型，就是一个对象的所属的类（大概这么理解吧。。。），例如在java中一个字符串，它的类型就是<code>java/lang/String</code>。在Dex文件头中，跟类的类型有关的一共有八个字节，分别是位于<code>0x40</code>处占四个字节表示类的类型的数量和位于<code>0x44</code>处占四个字节表示类的类型索引值的起始偏移地址，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_type/3.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、关于类的类型数量，没什么好说的，只需要注意它是以小端序存储的，读取的时候注意即可。对于类的类型偏移地址，找到偏移地址后，它是以四个字节为一组，对应了在解析出来的字符串数组中的索引值，例如下图中的第一组，它的数据是<code>BE 04 00 00</code>，我们读取出来就是<code>0x04BE</code>(同样采用的小端序存储)，对应的类的类型就是<code>字符串数组[0x04be]</code>。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_type/4.png">  </p>
<hr>
<h1 id="三、解析脚本"><a href="#三、解析脚本" class="headerlink" title="三、解析脚本"></a>三、解析脚本</h1><p><strong>&ensp;PS：我电脑上脚本运行环境python3.6</strong>  </p>
<p><strong>运行效果：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_type/1.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_type/2.png"></p>
<p><strong>代码如下：</strong>  </p>
<pre><code>import binascii
import os
import sys

def getStringsCount(f):
    f.seek(0x38)
    stringsId = f.read(4)
    a = bytearray(stringsId)
    a.reverse()
    stringsId = bytes(a)
    stringsId = str(binascii.b2a_hex(stringsId),encoding=&#39;UTF-8&#39;)
    count = int(stringsId,16)
    return count

def getStringByteArr(f,addr):
    byteArr = bytearray()
    f.seek(addr + 1)
    b = f.read(1)
    b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
    b = int(b,16)
    index = 2
    while b != 0:
        byteArr.append(b)
        f.seek(addr + index)
        b = f.read(1)
        b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
        b = int(b,16)
        index = index + 1
    return byteArr

def BytesToString(byteArr):
    try:
        bs = bytes(byteArr)
        stringItem = str(bs,encoding=&#39;UTF-8&#39;)
        return stringItem
    except:
        pass

def getAddress(addr):
    address = bytearray(addr)
    address.reverse()
    address = bytes(address)
    address = str(binascii.b2a_hex(address),encoding=&#39;UTF-8&#39;)
    address = int(address,16)
    return address

def getStrings(f,stringAmount):
    stringsList = []
    f.seek(0x3c)
    stringOff = f.read(4)
    Off = getAddress(stringOff)
    f.seek(Off)
    for i in range(stringAmount):
        addr = f.read(4)
        address = getAddress(addr)
        byteArr = getStringByteArr(f,address)
        stringItem = BytesToString(byteArr)
        stringsList.append(stringItem)
        Off = Off + 4
        f.seek(Off)
    return stringsList

def getTypeAmount(f):
    f.seek(0x40)
    stringsId = f.read(4)
    a = bytearray(stringsId)
    a.reverse()
    stringsId = bytes(a)
    stringsId = str(binascii.b2a_hex(stringsId),encoding=&#39;UTF-8&#39;)
    count = int(stringsId,16)
    return count

def getTypeItem(f,count,strLists):
    f.seek(0x44)
    type_ids_off = f.read(4)
    a = bytearray(type_ids_off)
    a.reverse()
    type_ids_off = bytes(a)
    type_ids_off = binascii.b2a_hex(type_ids_off)
    type_ids_off = str(type_ids_off,encoding=&#39;utf-8&#39;)
    type_off = int(type_ids_off,16)
    f.seek(type_off)
    print(&#39;[+] type count ==&gt; &#39;,end=&#39;&#39;)
    print(count)
    for i in range(count):
        typeIndex = f.read(4)
        b = bytearray(typeIndex)
        b.reverse()
        typeIndex = bytes(b)
        typeIndex = binascii.b2a_hex(typeIndex)
        typeIndex = int(str(typeIndex,encoding=&#39;UTF-8&#39;),16)
        print(&#39;[*] typeItem ==&gt; &#39;,end=&#39;&#39;)
        print(strLists[typeIndex])
        type_off = type_off + 0x04
        f.seek(type_off)

if __name__ == &#39;__main__&#39;:
    filename = str(os.path.join(sys.path[0])) + &#39;\\1.dex&#39;
    f = open(filename,&#39;rb&#39;,True)
    stringsCount = getStringsCount(f)
    strList = getStrings(f,stringsCount)
    typeCount = getTypeAmount(f)
    getTypeItem(f,typeCount,strList)
    f.close()
</code></pre>
<h1 id="四、样本以及代码下载链接"><a href="#四、样本以及代码下载链接" class="headerlink" title="四、样本以及代码下载链接"></a>四、样本以及代码下载链接</h1><p><strong>&ensp;&ensp;百度网盘：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1Z1nn8hroxX-2jGaKvhmIZQ">https://pan.baidu.com/s/1Z1nn8hroxX-2jGaKvhmIZQ</a>；提取码:1eao</strong>  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/04/04/15/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/15/" class="post-title-link" itemprop="url">DEX文件解析--3、dex文件字符串解析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-04-04 17:06:15" itemprop="dateCreated datePublished" datetime="2020-04-04T17:06:15+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 22:47:59" itemprop="dateModified" datetime="2024-11-12T22:47:59+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p><strong>&ensp;&ensp;&ensp;前两篇文章链接：</strong><br>  <strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1057245-1-1.html">1、DEX文件头解析</a></strong><br>  <strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1070218-1-1.html">2、DEX文件校验和解析</a></strong>  </p>
<p>  <strong>&ensp;&ensp;&ensp;PS：前几天检查文件夹的时候发现DEX文件解析还只写了开头，正好找点事情来做，就去接着解析DEX文件其余部分了。。。。。（还得多亏了一波疫情，不然都忘了还有这回事了。。。）</strong>  </p>
<hr>
<h1 id="二、DEX文件中的字符串"><a href="#二、DEX文件中的字符串" class="headerlink" title="二、DEX文件中的字符串"></a>二、DEX文件中的字符串</h1><p>  <strong>&ensp;&ensp;&ensp;&ensp;1、DEX文件大致上可以粗略的分为3个部分：文件头、索引区以及数据区。而文件头一般来说占了整个DEX文件0x70个字节（还不了解DEX文件头的可以看一下我前面两篇文章），在文件头中，关于字符串的相关信息一共有8个字节，分别位于0x38(4 Bytes)和0x3c(4 Bytes)处，前者说明了该DEX文件包含了多少个字符串，后者则是字符串索引区的起始地址，但是需要注意的是，DEX存储是以小端序存储的（通俗一点的说就是从后往前读），如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_string/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、前面我们通过文件头知道了字符串数量和字符串索引区起始地址等信息，接下来我们就来具体看一下字符串索引区。字符串索引区存储的是字符串真正存储在数据区的偏移地址，以4个字节为一组，表示一个字符串在数据区的偏移地址，所以索引区一个占<code>字符串数量 X 4</code>个字节那么多，同样的，索引区也采用的是小端序存储，所以我们在读取地址时，需要与小端序的方式来读取真正的地址，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_string/2.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、从上面我们已经知道了如何找到字符串在数据区的偏移地址，接下来我们需要做的就是解析这些数据区的字节。通过偏移地址我们可以在数据区找到代表字符串的这些字节，在DEX文件中，字符串是通过<code>MUTF-8</code>编码而成的（至于mutf-8是什么编码，我会将一些相关博客链接贴在文末），在<code>MUTF-8</code>编码中，第一个字节代表了这个字符串所需要用到的字节数目（不包括最后一个代表终结的字节），最后一个字节为<code>0x00</code>，表示这个字符串到此结束，跟c语言有点类似，中间部分才是一个字符串的具体内容，如下所示：(PS:<code>mutf-8</code>第一个字节还经过<code>uleb128</code>编码，所以简单的进行进制换算得到的字节数很多人奇怪对不上，由于比较复杂，就不过多解释了，想进一步了解更深的可以去看一下安卓源码中对DEX文件解析出字符串这一部分)</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_string/3.png">  </p>
<hr>
<h1 id="三、解析代码："><a href="#三、解析代码：" class="headerlink" title="三、解析代码："></a>三、解析代码：</h1><p><strong>&ensp;&ensp;&ensp;&ensp;PS：我电脑运行环境–python3.6</strong>  </p>
<p><strong>代码如下：</strong>  </p>
<pre><code>import binascii
import os
import sys

def getStringsCount(f):
    f.seek(0x38)
    stringsId = f.read(4)
    a = bytearray(stringsId)
    a.reverse()
    stringsId = bytes(a)
    stringsId = str(binascii.b2a_hex(stringsId),encoding=&#39;UTF-8&#39;)
    count = int(stringsId,16)
    print(&#39;[+] stringSize ==&gt; &#39; + str(count))
    return count

def getStringByteArr(f,addr):
    byteArr = bytearray()
    f.seek(addr + 1)
    b = f.read(1)
    b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
    b = int(b,16)
    index = 2
    while b != 0:
        byteArr.append(b)
        f.seek(addr + index)
        b = f.read(1)
        b = str(binascii.b2a_hex(b),encoding=&#39;UTF-8&#39;)
        b = int(b,16)
        index = index + 1
    return byteArr

def BytesToString(byteArr):
    try:
        bs = bytes(byteArr)
        stringItem = str(bs,encoding=&#39;UTF-8&#39;)
        print(&#39;[*] str = &#39; + stringItem)
        return stringItem
    except:
        pass

def getAddress(addr):
    address = bytearray(addr)
    address.reverse()
    address = bytes(address)
    address = str(binascii.b2a_hex(address),encoding=&#39;UTF-8&#39;)
    address = int(address,16)
    return address

def getStrings(f,stringAmount):
    stringsList = []
    f.seek(0x3c)
    stringOff = f.read(4)
    Off = getAddress(stringOff)
    f.seek(Off)
    for i in range(stringAmount):
        addr = f.read(4)
        address = getAddress(addr)
        byteArr = getStringByteArr(f,address)
        stringItem = BytesToString(byteArr)
        stringsList.append(stringItem)
        Off = Off + 4
        f.seek(Off)

if __name__ == &#39;__main__&#39;:
    filename = str(os.path.join(sys.path[0])) + &#39;\\1.dex&#39;
    f = open(filename,&#39;rb&#39;,True)
    stringsCount = getStringsCount(f)
    getStrings(f,stringsCount)
    f.close()
</code></pre>
<p><strong>运行截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_string/5.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//dex_string/4.png"></p>
<hr>
<h1 id="四、一些总结"><a href="#四、一些总结" class="headerlink" title="四、一些总结"></a>四、一些总结</h1><p><strong>&ensp;&ensp;&ensp;&ensp;其实也没有什么好总结的，因为本身这没有什么难点之处，就记录一些遇见的问题吧！！！最开始解析字符串的时候发现<code>MUTF-8</code>编码的时候好不容易弄懂了的时候，发现还经过<code>uleb128</code>，所以最开始一直没办法通过第一个字节计算出需要编码的字节个数，最后取了个巧，从第二个字节开始读取知道读取到<code>0x00</code>为止；然后是怎么编码这些字节显示字符串，后来看了一下姜维大佬写的解析代码，发现直接用的是<code>utf-8</code>进行编码，转念一想，<code>mutf-8</code>也是<code>utf-8</code>的变种，所以大部分解析出来基本没有问题。写完代码后本来打算去看一下安卓源码是怎么解析这一块的再来模仿一下，但是这疫情让我已经耍了这么久了，实在没精神去看了，我还是接着去微博上蹲在@四川教育吧，看源码什么的还是开学了再说吧！！！</strong>  </p>
<hr>
<h1 id="五、一下链接和附件"><a href="#五、一下链接和附件" class="headerlink" title="五、一下链接和附件"></a>五、一下链接和附件</h1><p><strong>&ensp;&ensp;1、相关知识链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/Roland_Sun/article/details/46716965">MUTF-8编码:https://blog.csdn.net/Roland_Sun&#x2F;article&#x2F;details&#x2F;46716965</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/Roland_Sun/article/details/46708061">uleb128:https://blog.csdn.net/Roland_Sun&#x2F;article&#x2F;details&#x2F;46708061</a></strong>  </p>
<p><strong>&ensp;&ensp;2、样本及代码下载链接：</strong><br><strong>&ensp;&ensp;&ensp;&ensp;百度网盘链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1_CQP7Zrj9LHcLOIjdGD95A">https://pan.baidu.com/s/1_CQP7Zrj9LHcLOIjdGD95A</a>；提取码：yc9y</strong>  </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/03/28/26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/28/26/" class="post-title-link" itemprop="url">XCTF mobile新手区解题记录以及一些总结和思考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-28 17:44:26" itemprop="dateCreated datePublished" datetime="2020-03-28T17:44:26+08:00">2020-03-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 22:48:40" itemprop="dateModified" datetime="2024-11-12T22:48:40+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.4k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>&ensp;&ensp;&ensp;&ensp;疫情当下，都已经耍了好几个月了，都不知道干啥了，好不容易等到我四川宣布开学时间了，结果四川高校一点动静都没有，无聊中，那就写一下解题记录吧，有些题先前已经在我个人博客上发过了，就不再重复写了，贴个链接就行了！！！</strong></p>
<hr>
<h1 id="题目：app3"><a href="#题目：app3" class="headerlink" title="题目：app3"></a>题目：app3</h1><p><strong>&ensp;&ensp;&ensp;&ensp;此题wp已经在个人博客写过，不在详细说明，详情请看链接：<a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1082706-1-1.html">https://www.52pojie.cn/thread-1082706-1-1.html</a></strong>  </p>
<hr>
<h1 id="题目：easy-apk"><a href="#题目：easy-apk" class="headerlink" title="题目：easy-apk"></a>题目：easy-apk</h1><p><strong>&ensp;&ensp;&ensp;&ensp;此题wp已经在个人博客写过，不在详细说明，详情请看链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aWxvdmVseXc0/p/11955006.html">https://www.cnblogs.com/aWxvdmVseXc0/p/11955006.html</a></strong>  </p>
<hr>
<h1 id="题目：easy-java"><a href="#题目：easy-java" class="headerlink" title="题目：easy-java"></a>题目：easy-java</h1><p><strong>&ensp;&ensp;&ensp;&ensp;此题wp已经在个人博客写过，不在详细说明，详情请看链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aWxvdmVseXc0/p/12207697.html">https://www.cnblogs.com/aWxvdmVseXc0/p/12207697.html</a></strong>  </p>
<hr>
<h1 id="题目：easy-jni"><a href="#题目：easy-jni" class="headerlink" title="题目：easy-jni"></a>题目：easy-jni</h1><p><strong>&ensp;&ensp;&ensp;&ensp;此题wp已经在个人博客写过，不在详细说明，详情请看链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aWxvdmVseXc0/p/12198459.html">https://www.cnblogs.com/aWxvdmVseXc0/p/12198459.html</a></strong>  </p>
<hr>
<h1 id="题目：easy-so"><a href="#题目：easy-so" class="headerlink" title="题目：easy-so"></a>题目：easy-so</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、下载好题目，拖入夜神中，打开如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_so/2.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、查壳，发现无壳，用jeb反编译后，找到关键字<code>验证失败</code>所在类，发现调用了so层的<code>CheckString</code>函数进行了验证，传进去的参数为我们在输入框中输入的字符串，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_so/1.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_so/3.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_so/4.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、用IDA打开so文件（要提取x86文件夹下面那个so文件，两个arm文件夹下面的so文件用ida打开有问题），找到该静态函数，直接F5大法，静态分析该函数可知：首先将传入的字符串前16位与后16位互换，然后两两一组互换位置，最后将得到的字符串与字符串<code>f72c5a36569418a20907b55be5bf95ad</code>比较返回比较结果！！！</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_so/5.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_so/6.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;4、写了一个python小脚本跑出flag，如下所示：</strong>  </p>
<p><strong>脚本代码：</strong>  </p>
<pre><code>string = &#39;f72c5a36569418a20907b55be5bf95ad&#39;
strlist = list(string)

k = 0

for i in range(16):
    ch = strlist[1 + k]
    strlist[1 + k] = strlist[0 + k]
    strlist[0 + k] = ch
    k = k + 2

k = 0

for i in range(16):
    ch = strlist[0 + k]
    strlist[0 + k] = strlist[16 + k]
    strlist[16 + k] = ch
    k = k + 1

print(&#39;&#39;.join(strlist))
</code></pre>
<p><strong>运行截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_so/8.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_so/7.png"></p>
<hr>
<h1 id="题目：app1"><a href="#题目：app1" class="headerlink" title="题目：app1"></a>题目：app1</h1><p><strong>&ensp;&ensp;&ensp;&ensp;此题wp已经在个人博客写过，不在详细说明，详情请看链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aWxvdmVseXc0/p/11902184.html">https://www.cnblogs.com/aWxvdmVseXc0/p/11902184.html</a></strong>  </p>
<hr>
<h1 id="题目：Ph0en1x-100"><a href="#题目：Ph0en1x-100" class="headerlink" title="题目：Ph0en1x-100"></a>题目：Ph0en1x-100</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、拖进夜神中安装运行，主界面只有一个输入框和一个按钮，随便输入信息，点击按钮后，弹出信息<code>Failed!</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_ph0en1x_100/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、查壳后无壳直接使用JEB反编译，查看MainActivity.java文件，发现要弹出信息<code>Success</code>逻辑如下：首先在so层注册了两个静态函数–<code>encrypt(String)</code>、<code>getFlag()</code>函数，然后在java层有个函数<code>getSecret(String)</code>，将so层函数<code>getFlag</code>返回值经过<code>getSecret</code>函数加密后与我们在输入框中输入的字符串经过<code>encrypt</code>函数后在经过<code>getSecret</code>函数加密比较，如果一致，则返回<code>Success</code>，由于比较的两个字符串最外层都经过<code>getSecret</code>函数加密，所有我们不需要在管<code>getSecret</code>函数，直接让内部两个字符串一直一致即可得到flag！！！</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_ph0en1x_100/6.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_ph0en1x_100/7.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、使用IDA打开so文件，静态分析一下<code>encrypt</code>函数，发现逻辑很简单，就是将传进来的字符串的每个字符的ASCII码减一；对于<code>getFlag</code>函数，由于该函数没有输入只有输出，直接用frida Hook该函数得到返回值即可，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_ph0en1x_100/2.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_ph0en1x_100/3.png">  </p>
<p><strong>Frida代码：</strong>  </p>
<pre><code>import frida
import sys

jscode = &quot;&quot;&quot;
Java.perform(function()&#123;
    Interceptor.attach(Module.findExportByName(&quot;libphcm.so&quot;,&quot;Java_com_ph0en1x_android_1crackme_MainActivity_getFlag&quot;),&#123;
        onEnter: function(args) &#123;
        &#125;,
        onLeave: function(retval)&#123;
            var String_java = Java.use(&#39;java.lang.String&#39;);
            var args_4 = Java.cast(retval, String_java);
            send(&quot;getFlag()==&gt;&quot;+args_4);
        &#125;
    &#125;);
&#125;);
&quot;&quot;&quot;
def printMessage(message,data):
    if message[&#39;type&#39;] == &#39;send&#39;:
        print(&#39;[*] &#123;0&#125;&#39;.format(message[&#39;payload&#39;]))
    else:
        print(message)

process = frida.get_remote_device().attach(&#39;com.ph0en1x.android_crackme&#39;)
script = process.create_script(jscode)
script.on(&#39;message&#39;,printMessage)
script.load()
sys.stdin.read()
</code></pre>
<p><strong>&ensp;&ensp;&ensp;&ensp;4、得到以上信息后，使用python脚本跑出falg即可，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_ph0en1x_100/4.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_ph0en1x_100/5.png">  </p>
<p><strong>python脚本：</strong>  </p>
<pre><code>Flag = &#39;ek`fz@q2^x/t^fn0mF^6/^rb`qanqntfg^E`hq|&#39;

flaglist = list(Flag)

stringlist = []

for ch in flaglist:
    stringlist.append(chr(ord(ch) + 1))
    
print(&#39;&#39;.join(stringlist))
</code></pre>
<hr>
<h1 id="题目：RememberOther"><a href="#题目：RememberOther" class="headerlink" title="题目：RememberOther"></a>题目：RememberOther</h1><p><strong>&ensp;&ensp;&ensp;&ensp;PS：此题为脑洞题，披了一个安卓的皮而已！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;1、下载好题目后，查壳发现无壳，直接拖进夜神中，要求输入用户名和注册码，随便输入，弹出信息<code>无效用户名或注册码</code>，如下图所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_RememberOther/1.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_RememberOther/2.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、用JEB反编译后，查看<code>onCreate</code>方法，发现将我们输入的用户名和注册码作为参数调用<code>checkSN</code>函数，并且当该函数返回<code>false</code>时不弹出信息<code>无效用户名或注册码</code>，接着去看<code>checkSN</code>函数，该函数当用户名和注册码为空时返回<code>false</code>，返回false后弹出了一串md5值，再看<code>checkSN</code>函数其他逻辑，发现将输入的用户名经过md5加密后返回16进制字符串，然后取该字符串的奇数位拼接成一个新的字符串，再然后与我们输入的注册码进行比较，返回<code>true</code>，最后也没有发现这个跟flag没什么关系，想起之前还有一串md5值，进行解密，解密得出<code>YOU_KNOW_</code>，输入，提示flag错误。。。看了一下其他大佬的wp，才发现在后面加上<code>ANDROID</code>就行了。。。。。因为压缩包里面有个word文件，里面写了不懂安卓。。。。。。。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_RememberOther/5.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_RememberOther/6.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_RememberOther/7.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_RememberOther/8.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_RememberOther/4.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_RememberOther/3.png">  </p>
<hr>
<h1 id="题目：app2"><a href="#题目：app2" class="headerlink" title="题目：app2"></a>题目：app2</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、将下载好的题目拖进夜神中，发现要求登陆，随便点击登陆后，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_app2/1.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_app2/2.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、将apk用jeb反编译后，首先看一下MainActivity这个入口文件，发现没什么，就是将我们输入的用户名和密码传入SecondActivity页面中，然后跳转到该页面，再来看一下SecondActivity，发现调用了so层函数<code>doRawData</code>，使其返回值和字符串<code>VEIzd/V2UPYNdn/bxH3Xig==</code>进行比较，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_app2/3.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_app2/5.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、用IDA查看一下该函数，发现至少将传入的字符串进行了<code>AES-128-ECB</code>加密，并且发现密钥<code>thisisatestkey==</code>，将开始我们发现的字符串<code>VEIzd/V2UPYNdn/bxH3Xig==</code>进行解密，得到的字符串输入后发现不是flag，但是在FileDataActivity文件中发现另一串字符串<code>9YuQ2dk8CSaCe7DTAmaqAA==</code>，对其解密，得到flag:<code>Cas3_0f_A_CAK3</code></strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_app2/4.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_app2/6.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_app2/7.png">  </p>
<hr>
<h1 id="题目：黑客精神"><a href="#题目：黑客精神" class="headerlink" title="题目：黑客精神"></a>题目：黑客精神</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、将下载好的题目拖进夜神模拟器中，发现要求注册，随便点击注册后，弹出一个弹框，提示<code>已注册</code>。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、用JEB反编译后，跟进MainActivity文件，发现点击按钮后就一个弹出弹框，点击弹框确定后，跳转到RegActivity界面去，在该界面点击注册后，调用了so层函数<code>saveSN</code>。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/2.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/9.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、用IDA分析so文件发现在java层注册的native函数都是动态注册的，此时用<code>Ctrl+S</code>找到<code>.data</code>段进入，发现对应的函数<code>n1</code>、<code>n2</code>、<code>n3</code>。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/3.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/4.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;4、先分析一些<code>n1</code>函数，<code>F5</code>大法后，可以很轻易看出该函数作用是创建了一个文件<code>/sdcard/reg.dat</code>，然后读取该文件，与字符串<code>EoPAoY62@ElRD</code>进行比较；再来看一下<code>n2</code>函数，该函数对应这java层的<code>saveSN</code>函数，首先前面做了一大堆令人看不懂的操作，然后将我们输入的注册码的每个字符与另一个字符进行异或操作（该字符我们不知道，所以无法得到最终异或结果）；再来看一下<code>n3</code>函数，该函数首先调用了<code>n1</code>函数，若结果为真，则将一大串字符串赋值给<code>v4</code>，双击去看一些该字符串，使用<code>A</code>健将其转为ascii后，发现提示<code>输入即是flag,格式为xman&#123;……&#125;！</code>。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/5.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/6.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/7.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/8.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;5、按照提示，我们将开始发现的字符串<code>EoPAoY62@ElRD</code>(只发现这一个字符串，不输入这个输入啥)作为字符串进行输入，然后将文件<code>/sdcard/reg.dat</code>拷贝出来，打开文件一看，发现flag！！！</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/10.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_hack/11.png">  </p>
<hr>
<h1 id="题目：easy-dex"><a href="#题目：easy-dex" class="headerlink" title="题目：easy-dex"></a>题目：easy-dex</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、下载好题目后，拖进夜神中，发现直接是黑屏的，在JEB中反编译后，发现在<code>AndroidManifest.xml</code>文件<code>application</code>和<code>activity</code>标签中存在<code>android:hasCode=&quot;false&quot;</code>和<code>android:name=&quot;android.app.NativeActivity&quot;</code>，说明这是个纯C++编写的，并且不含java代码，也就是<code>Native Activity</code>。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/13.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/2.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、既然是<code>Native Activity</code>，直接找到so文件，拖进IDA中，寻找<code>android_main</code>方法（这是<code>Native Activity</code>的入口方法，关于<code>Native Activity</code>的一些基础知识，我会在将一些我觉得写得比较好的博客链接附在文末），发现存在一个’write’方法，结合包名’findmydex’，大胆推测一波此处就是将dex写入某个文件中，那么直接开启动态调试，在关键地方下好断点后，终于运行到了<code>write</code>函数处，结合传进去的参数，直接dump下来整个内存，用010打开一看，全都是’00000…..’，。。。。。卒！！！！。。。。。。。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、好吧，开玩笑的！！！动态调试dump下来的内存有问题，一看就不是dex文件，开始还以为调试的时候哪里出来问题，导致dump出来的有问题，然后接着动态了一整个下午，发现好像dump下来的加密后的dex，去看了一下大佬们的wp，发现都是dump下加密后的dex，然后直接解密，好吧，再来看<code>android_main</code>函数，发现一开始就通过<code>_aeabi_memcpy</code>函数将加密后的<code>dex</code>文件加载进来了，我们可以轻松看到加密后的dex文件首地址为<code>0x7004</code>(ida使用F5后，要使用那一块内存空间地址直接是以&amp;unk_地址命名的，所以首地址可以轻松看出来是<code>0x7004</code>)，大小为<code>0x3ca10</code>，那么直接在静态下执行dump脚本即可，至于解密，把想应的c语言转换为python即可，至于最后为啥要进行一次zip的解压操作，是因为在<code>android_main</code>函数中解密完成后调用了<code>uncompress</code>函数进行了解压缩（更偷懒的可以直接把F5后的c代码复制下来，替换一下就行了）。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/3.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/4.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/5.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/11.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/6.png">  </p>
<p><strong>&ensp;IDA dump脚本：</strong>  </p>
<pre><code>import idaapi

addr = 0x7004
size = 0x3ca10

with open(&#39;dump&#39;,&#39;wb&#39;) as f:
    f.write(get_bytes(addr,size))
    
print(&#39;[+] dump end&#39;)
</code></pre>
<p><strong>&ensp;python解密dex脚本（我电脑上运行环境为3.6）：</strong>  </p>
<pre><code>import zlib

with open(&#39;dump&#39;,&#39;rb&#39;) as f:
    data1 = f.read()
    
    data = list(data1)
    
    count = 0
    
    while True:
        if count &lt;= 0x59:
            count_tmp = (int)(count / 10)
            if count % 10 == 9:
                size = 0x3ca10
                size_tmp = (int)(size / 10)
                xor = (count_tmp + 1) * size_tmp
                if (size_tmp * count_tmp) &lt; xor:
                    index = size_tmp * count_tmp
                    while size_tmp:
                        data[index] = data[index] ^ count
                        index = index + 1
                        size_tmp = size_tmp - 1
                if count == 89:
                    while xor &lt; size:
                        data[xor] = data[xor] ^ 0x59
                        xor = xor + 1
        else:
            break
        count = count + 1

filebytes = bytes(data)
with open(&#39;easy-dex.dex&#39;,&#39;wb&#39;) as f1:
    f1.write(zlib.decompress(filebytes))
print(&#39;[+] decrypt end&#39;)
</code></pre>
<p><strong>&ensp;&ensp;&ensp;&ensp;4、将解密后的dex文件拖进jeb中反编译，首先看一下<code>MainActivity.java</code>文件的<code>onCreate</code>函数，发现有一个按钮监听事件，触发后调用了<code>a.java</code>里面的<code>onClick</code>函数，那么去看一下<code>onclick</code>函数，发现调用了<code>MainActivity</code>里面的<code>a</code>函数，并且传入了两个字符串参数，第一个字符串是输入框中的值，第二个参数是<code>string.xml</code>资源文件中的字符串，然后与一个字节数组进行比较，结合题目反编译后的<code>public.xml</code>和<code>string.xml</code>文件，该字符串为<code>I have a male fish and a female fish.</code>，并且资源ID为<code>two_fish</code>，好吧，都已经是明示了，这里是<code>TwoFish</code>加密（关于TwoFish加密我会将一下我觉得写得还行的博客链接贴在最后面），并且该字符串就是密钥，与之比较字节数组就是加密后的结果。那么首先将字节数组转为字符串再说吧，一看字符串里面还有负数，那就直接与一下0xff咯（关于为啥要与0xff，是因为数字在java中是以补码形式表示的，与0xff相当于将一个有符号数转为了无符号数，看来我确实没有写博客的天赋，感觉说得不明不白的，老规矩，就把我觉得写得可以的博客链接贴在文末），然后与完后，直接转为ascii拼接成字符串，发现有些根本无法显示出具体字符来。。。。。又卡了，突然发现里面有个<code>/</code>符号，一下就想到了<code>base64</code>，尝试一下base4解码，结果解出来又是啥都不是。。。。。好气哦这个题。。。。。那就在来一个base64加密吧，得到字符串<code>iE3y2hEF1izgbVUfGKWQrUCtgFQFop7iEkbmRwWdwsZ1HdQGcPxRVAkWzV/eDC9N</code>（好吧，我承认我有赌的成分。。。。），随便找了个在线解密的网站，解密即得到flag。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/7.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/8.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/9.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/10.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//xctf_easy_dex/12.png"> </p>
<p><strong>&ensp;python获取twofish加密结果脚本（运行环境同上）：</strong>  </p>
<pre><code>import base64

i = [-120, 77, -14, -38, 17, 5, -42, 44, -32, 109, 85, 31, 24, -91, -112, -83, 64, -83, -128, 84, 5, -94, -98, -30, 18, 70, -26, 71, 5, -99, -62, -58, 117, 29, -44, 6, 112, -4, 81, 84, 9, 22, -51, 95, -34, 12, 47, 77]

data = []

for k in i:
    data.append(k&amp;0xff)
print(base64.b64encode(bytes(data)))
</code></pre>
<hr>
<h1 id="题目：我是谁"><a href="#题目：我是谁" class="headerlink" title="题目：我是谁"></a>题目：我是谁</h1><p><strong>&ensp;&ensp;&ensp;&ensp;55555555555，我太菜了，这道题还没有做出来，。。。。。。。。。。。。。。。。等做出来在补上！！！</strong>  </p>
<hr>
<h1 id="一些总结"><a href="#一些总结" class="headerlink" title="一些总结"></a>一些总结</h1><p><strong>&ensp;&ensp;&ensp;&ensp;1、以往反编译后的第一步是看<code>MainActivity</code>文件，很少看<code>AnroidMainifes.xml</code>，结果在很多地方吃了大亏，比如<code>easy-dex</code>这个题，<code>android_main</code>这个函数还是撞进去的，后来看见那两个标签觉得没见过，才去百度了一下，才知道是<code>Native Activity</code>，感觉这个文件看似不起眼，结果能少走一些不必要的地方！！！</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、思想上的牛角尖比技术上的牛角尖更难受，不然也不会去傻乎乎动态调试了一下午了！！！</strong>  </p>
<hr>
<h1 id="一些博客链接"><a href="#一些博客链接" class="headerlink" title="一些博客链接"></a>一些博客链接</h1><p><strong>&ensp;关于Native Activity的：</strong><br><strong>&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_19683651/article/details/82623717">https://blog.csdn.net/qq_19683651&#x2F;article&#x2F;details&#x2F;82623717</a></strong><br><strong>&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_21071977/article/details/77878252">https://blog.csdn.net/qq_21071977&#x2F;article&#x2F;details&#x2F;77878252</a></strong>  </p>
<p><strong>&ensp;关于TwoFish加密的：</strong><br><strong>&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/l540538550/article/details/5642435">https://blog.csdn.net/l540538550/article/details/5642435</a></strong>  </p>
<p><strong>&ensp;关于与0xff的：</strong><br><strong>&ensp;&ensp;<a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_ds/article/details/79106006?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/csdn_ds&#x2F;article&#x2F;details&#x2F;79106006?depth_1-utm_source&#x3D;distribute.pc_relevant.none-task&amp;utm_source&#x3D;distribute.pc_relevant.none-task</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://windy-purple.github.io/2020/03/11/48/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="windy_ll">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="windy_ll">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/03/11/48/" class="post-title-link" itemprop="url">frida入门总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-11 16:39:48" itemprop="dateCreated datePublished" datetime="2020-03-11T16:39:48+08:00">2020-03-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-12 22:49:19" itemprop="dateModified" datetime="2024-11-12T22:49:19+08:00">2024-11-12</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、Frida概述"><a href="#一、Frida概述" class="headerlink" title="一、Frida概述"></a>一、Frida概述</h2><p><strong>&ensp;&ensp;&ensp;&ensp;Frida是一款轻量级HOOK框架，可用于多平台上，例如android、windows、ios等。</strong><br><strong>&ensp;&ensp;&ensp;&ensp;frida分为两部分，服务端运行在目标机上，通过注入进程的方式来实现劫持应用函数，另一部分运行在系统机器上。</strong><br><strong>&ensp;&ensp;&ensp;&ensp;frida上层接口支持js、python、c等。</strong><br><strong>&ensp;&ensp;&ensp;&ensp;Frida官方github地址为：<a target="_blank" rel="noopener" href="https://github.com/frida">frida官方github地址</a></strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;PS：虽然百度一下会发现frida教程有不少，但是涉及到native层的教程基本很少，然后对每一句Hook代码解释一下的更是少之又少，所以我还是厚着脸皮从自己的角度写了这一篇！！！</strong></p>
<hr>
<h2 id="二、Frida安装"><a href="#二、Frida安装" class="headerlink" title="二、Frida安装"></a>二、Frida安装</h2><p><strong>&ensp;&ensp;&ensp;&ensp;1 、安装python3.7并配置好环境变量（官方推荐python3以上版本至少为3.7），python安装包官方下载地址：<a target="_blank" rel="noopener" href="https://www.python.org/downloads/">https://www.python.org/downloads/</a>。</strong>  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2 、安装frida模块，命令为<code>pip install frida</code>(配置了多个python版本环境的可以使用命令<code>python -m pip install frida</code>防止用<code>pip install frida</code>命令报错)。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/1.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、安装frida-tools模块，命令同上，<code>pip install frida-tools</code>或者<code>python -m pip install frida-tools</code>。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/2.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;4、下载运行在目标机上的frida-sever端，官方下载地址：<a target="_blank" rel="noopener" href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a>，下载时要选择对应的版本下载，例如我的机器为arm32为架构，就选择<code>frida-server-12.8.14-android-arm.xz</code>下载。（可以在adb使用命令<code>cat /proc/cpuinfo</code>查询）</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/3.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/4.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;5、将第四步下载好的文件解压，然后通过命令<code>adb push 你的电脑是存放位置 /data/local/tmp</code>将文件传输到手机中，然后通过<code>adb shell</code>进入手机端，给文件赋权777，并于root权限启动。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/5.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/6.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;6、做完以上几步后，新开一个命令行输入命令<code>frida-ps -U</code>查看手机进程，如果出现以下结果，则frida安装成功。</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/7.png">  </p>
<hr>
<h2 id="三、Frida-Hook-Java层"><a href="#三、Frida-Hook-Java层" class="headerlink" title="三、Frida Hook Java层"></a>三、Frida Hook Java层</h2><p><strong>&ensp;&ensp;&ensp;&ensp;1、编写一个小demo用来hook，该demo关键部分代码如下：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/8.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、现在我们将该apk安装好，运行看一下未Hook前的显示字符串！！！</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/9.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、现在来编写Hook的Python脚本，脚本代码如下：</strong>  </p>
<pre><code>import frida  #导入frida模块
import sys    #导入sys模块

jscode = &quot;&quot;&quot;  #从此处开始定义用来Hook的javascript代码
    Java.perform(function()&#123;  
        var MainActivity = Java.use(&#39;com.example.testfrida.MainActivity&#39;); //获得MainActivity类
        MainActivity.testFrida.implementation = function()&#123; //Hook testFrida函数，用js自己实现
            send(&#39;Statr! Hook!&#39;); //发送信息，用于回调python中的函数
            return &#39;Change String!&#39; //劫持返回值，修改为我们想要返回的字符串
        &#125;
    &#125;);
&quot;&quot;&quot;

def on_message(message,data): #js中执行send函数后要回调的函数
    print(message)
    
process = frida.get_remote_device().attach(&#39;com.example.testfrida&#39;) #得到设备并劫持进程com.example.testfrida（该开始用get_usb_device函数用来获取设备，但是一直报错找不到设备，改用get_remote_device函数即可解决这个问题）
script = process.create_script(jscode) #创建js脚本
script.on(&#39;message&#39;,on_message) #加载回调函数，也就是js中执行send函数规定要执行的python函数
script.load() #加载脚本
sys.stdin.read()
</code></pre>
<p><strong>&ensp;&ensp;&ensp;&ensp;4、现在python脚本编写完毕，我们来执行该脚本，首先手机端执行frida，然后通过命令<code>adb forward tcp:27043 tcp:27043</code>和<code>adb forward tcp:27042 tcp:27042</code>来转发这两个端口，接着在手机上运行该应用程序，在命令行中执行脚本，最后点击应用的按钮，即可看到字符串已经被替换成我们要替换的了！！！</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/6.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/10.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/11.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/12.png">  </p>
<hr>
<h2 id="四、Frida-Hook-Native层"><a href="#四、Frida-Hook-Native层" class="headerlink" title="四、Frida Hook Native层"></a>四、Frida Hook Native层</h2><h3 id="ensp-ensp-4-1、Hook-native层返回值为int类型的demo"><a href="#ensp-ensp-4-1、Hook-native层返回值为int类型的demo" class="headerlink" title="&ensp;&ensp;4.1、Hook native层返回值为int类型的demo"></a>&ensp;&ensp;4.1、Hook native层返回值为int类型的demo</h3><p><strong>&ensp;&ensp;&ensp;&ensp;1、还是先写一个小demo，下面贴一下关键代码（很简单c语言代码就不再解释了，至于native层函数怎么编写，由于本篇主要不是讲怎么编写so函数，就不过多叙述了，实在不会的可以看一下我的一篇博客，我觉得写得还是挺详细的，博客编写native层函数链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/aWxvdmVseXc0/p/11564809.html">https://www.cnblogs.com/aWxvdmVseXc0/p/11564809.html</a>）和未Hook前截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/23.png">  </p>
<p><strong>代码：</strong>  </p>
<pre><code>/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_example_fridaso_FridaSoDefine */

#ifndef _Included_com_example_fridaso_FridaSoDefine
#define _Included_com_example_fridaso_FridaSoDefine
#ifdef __cplusplus
extern &quot;C&quot; &#123;
#endif
/*
* Class:     com_example_fridaso_FridaSoDefine
* Method:    FridaSo
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_com_example_fridaso_FridaSoDefine_FridaSo(JNIEnv *env, jclass obj, jint a, jint b)
&#123;
    int c;
    c = a + b;
    return c;
&#125;

#ifdef __cplusplus
&#125;
#endif
#endif  
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/13.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/14.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、接下来我们来写python hook脚本，我们需要hook native层这个函数，达到返回值修改为0的效果。写到这里需要说明一下关于so文件当中的函数，分为导出函数和未导出函数两种，导出函数打开IDA后能够在导出表中找到的函数就是导出函数，未导出函数则在导出表中寻找不到，一般来说静态编写的native函数都能在导出表中寻找到，而动态加载的则无法在导出表中发现！！！</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/15.png">  </p>
<p><strong>代码如下：（跟上面hook java层重复的代码不在注释详讲了！！！）</strong>  </p>
<pre><code>import frida
import sys

jscode = &quot;&quot;&quot;
Java.perform(function()&#123;
    //下面这一句代码是指定要Hook的so文件名和要Hook的函数名，函数名就是上面IDA导出表中显示的那个函数名
    Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridaso_FridaSoDefine_FridaSo&quot;),&#123;
        //onEnter: function(args)顾名思义就是进入该函数前要执行的代码，其中args是传入的参数，一般so层函数第一个参数都是JniEnv，第二个参数是jclass，从第三个参数开始才是我们java层传入的参数
        onEnter: function(args) &#123;
            send(&quot;Hook start&quot;);
            send(&quot;args[2]=&quot; + args[2]); //打印我们java层第一个传入的参数
            send(&quot;args[3]=&quot; + args[3]); //打印我们java层传入的第二个参数
        &#125;,
        onLeave: function(retval)&#123; //onLeave: function(retval)是该函数执行结束要执行的代码，其中retval参数即是返回值
            send(&quot;return:&quot;+retval); //打印返回值
            retval.replace(0); //替换返回值为0
        &#125;
    &#125;);
&#125;);
&quot;&quot;&quot;
def printMessage(message,data):
    if message[&#39;type&#39;] == &#39;send&#39;:
        print(&#39;[*] &#123;0&#125;&#39;.format(message[&#39;payload&#39;]))
    else:
        print(message)

process = frida.get_remote_device().attach(&#39;com.example.fridaso&#39;)
script = process.create_script(jscode)
script.on(&#39;message&#39;,printMessage)
script.load()
sys.stdin.read()
</code></pre>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、最后在手机端执行frida-server，转发端口，开启应用，执行脚本，点击按钮，即可看到返回值已经被修改成了0，效果图如下：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/16.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/17.png">  </p>
<h3 id="ensp-ensp-4-2、Hook-native层返回值为String类型的demo"><a href="#ensp-ensp-4-2、Hook-native层返回值为String类型的demo" class="headerlink" title="&ensp;&ensp;4.2、Hook native层返回值为String类型的demo"></a>&ensp;&ensp;4.2、Hook native层返回值为String类型的demo</h3><p><strong>&ensp;&ensp;&ensp;&ensp;1、上面已经写了怎么Hook修改native层函数返回值为int类型的情况，使用<code>replace()</code>函数直接修改即可，但是返回情况为字符串则不一样，在c语言中，返回值为字符串其实是返回了一个<code>char *</code>（字符串指针），所以简单的替换是无法取效果的，具体怎么修改返回值，接着看下面，下面还是贴上demo的关键代码和未Hook前截图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/22.png">  </p>
<p><strong>代码如下：</strong>  </p>
<pre><code>/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_example_fridasostring_fridaSoString */

/* DO NOT EDIT THIS FILE - it is machine generated */
#include &lt;jni.h&gt;
/* Header for class com_example_fridasostring_fridaSoString */

#ifndef _Included_com_example_fridasostring_fridaSoString
#define _Included_com_example_fridasostring_fridaSoString
#ifdef __cplusplus
extern &quot;C&quot; &#123;
#endif
/*
* Class:     com_example_fridasostring_fridaSoString
* Method:    FridaSo
* Signature: (Ljava/lang/String;)Ljava/lang/String;
*/
JNIEXPORT jstring JNICALL Java_com_example_fridasostring_fridaSoString_FridaSo(JNIEnv *env, jclass obj, jstring str)
&#123;
    return str;
&#125;

#ifdef __cplusplus
&#125;
#endif
#endif
</code></pre>
<p><strong>未Hook前运行截图：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/18.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;2、接下来是python Hook脚本（只解释与上面有差异的代码），Hook的函数具体函数名还是使用IDA去寻找</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/19.png">  </p>
<p><strong>python代码：</strong>  </p>
<pre><code>import frida
import sys

jscode = &quot;&quot;&quot;
Java.perform(function()&#123;
    Interceptor.attach(Module.findExportByName(&quot;libfridaso.so&quot;,&quot;Java_com_example_fridasostring_fridaSoString_FridaSo&quot;),&#123;
        onEnter: function(args) &#123;
            send(&quot;Hook start&quot;);
            send(&quot;args[2]=&quot; + args[2]);
        &#125;,
        onLeave: function(retval)&#123;
            send(&quot;return:&quot;+retval);
            var env = Java.vm.getEnv(); //获取env对象，也就是native函数的第一个参数
            var jstrings = env.newStringUtf(&quot;tamper&quot;); //因为返回的是字符串指针，使用我们需要构造一个newStringUtf对象，用来代替这个指针
            retval.replace(jstrings); //替换返回值
        &#125;
    &#125;);
&#125;);
&quot;&quot;&quot;
def printMessage(message,data):
    if message[&#39;type&#39;] == &#39;send&#39;:
        print(&#39;[*] &#123;0&#125;&#39;.format(message[&#39;payload&#39;]))
    else:
        print(message)

process = frida.get_remote_device().attach(&#39;com.example.fridasostring&#39;)
script = process.create_script(jscode)
script.on(&#39;message&#39;,printMessage)
script.load()
sys.stdin.read()
</code></pre>
<p><strong>&ensp;&ensp;&ensp;&ensp;3、运行脚本后，点击按钮，我们可以看到字符串已经被替换成了<code>tamper</code>，如下所示：</strong>  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/20.png">  </p>
<p><img src="https://cdn.jsdelivr.net/gh/windy-purple/blog_picture_bed//frida/21.png">  </p>
<p><strong>&ensp;&ensp;&ensp;&ensp;4、关于为导出函数的Hook，大体上差不多，差别在于需要通过ida找到偏移值计算地址，而不是像导出函数这么方便罢了，但原理都是差不多的，就不在细说了！！！</strong>  </p>
<hr>
<h2 id="五、相关附件"><a href="#五、相关附件" class="headerlink" title="五、相关附件"></a>五、相关附件</h2><p><strong>&ensp;&ensp;&ensp;&ensp;python Hook代码已经demo下载链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1ZCIeJXzeTpQ8uJ9Ew5nnGQ">https://pan.baidu.com/s/1ZCIeJXzeTpQ8uJ9Ew5nnGQ</a></strong><br><strong>&ensp;&ensp;&ensp;&ensp;提取码：z94i</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">windy_ll</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">windy_ll</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">144k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:23</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
